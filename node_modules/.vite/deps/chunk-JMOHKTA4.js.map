{
  "version": 3,
  "sources": ["../../thirdweb/src/utils/bigint.ts", "../../viem/zksync/constants/address.ts", "../../thirdweb/src/transaction/actions/zksync/getEip721Domain.ts", "../../thirdweb/src/transaction/actions/zksync/send-eip712-transaction.ts"],
  "sourcesContent": ["import { uint8ArrayToHex } from \"./encoding/hex.js\";\n\n/**\n * Returns the minimum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The smaller of the two BigInt values.\n * @utils\n * @example\n * ```ts\n * min(1n, 2n)\n * // 1n\n */\nexport function min(a: bigint, b: bigint) {\n  return a < b ? a : b;\n}\n\n/**\n * Returns the maximum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The larger of the two BigInt values.\n * @utils\n * @example\n * ```ts\n * max(1n, 2n)\n * // 2n\n */\nexport function max(a: bigint, b: bigint) {\n  return a > b ? a : b;\n}\n\n/**\n * Provides error checking on string or number bigint inputs.\n * @param value - A possibly integer-like string, number, or bigint.\n * @returns The bigint representation of the input.\n * @example\n * ```ts\n * toBigInt(\"2\")\n * // 2n\n */\nexport function toBigInt(value: string | number | bigint | Uint8Array): bigint {\n  if (\n    [\"string\", \"number\"].includes(typeof value) &&\n    !Number.isInteger(Number(value))\n  ) {\n    throw new Error(\n      `Expected value to be an integer to convert to a bigint, got ${value} of type ${typeof value}`,\n    );\n  }\n\n  if (value instanceof Uint8Array) {\n    return BigInt(uint8ArrayToHex(value));\n  }\n\n  return BigInt(value);\n}\n\n// replaceBigInts courtesy of ponder.sh:\n// https://github.com/ponder-sh/ponder/blob/bc65b865898b6145e87031314192c59f9e8b621f/packages/utils/src/replaceBigInts.ts\ntype _ReplaceBigInts<\n  arr extends readonly unknown[],\n  type,\n  result extends readonly unknown[] = [],\n> = arr extends [infer first, ...infer rest]\n  ? _ReplaceBigInts<\n      rest,\n      type,\n      readonly [...result, first extends bigint ? type : first]\n    >\n  : result;\n\ntype ReplaceBigInts<obj, type> = obj extends bigint\n  ? type\n  : obj extends unknown[]\n    ? _ReplaceBigInts<Readonly<obj>, type>\n    : obj extends readonly []\n      ? _ReplaceBigInts<obj, type>\n      : obj extends object\n        ? { [key in keyof obj]: ReplaceBigInts<obj[key], type> }\n        : obj;\n\nexport const replaceBigInts = <const T, const type>(\n  obj: T,\n  replacer: (x: bigint) => type,\n): ReplaceBigInts<T, type> => {\n  if (typeof obj === \"bigint\") return replacer(obj) as ReplaceBigInts<T, type>;\n  if (Array.isArray(obj))\n    return obj.map((x) => replaceBigInts(x, replacer)) as ReplaceBigInts<\n      T,\n      type\n    >;\n  if (obj && typeof obj === \"object\")\n    return Object.fromEntries(\n      Object.entries(obj).map(([k, v]) => [k, replaceBigInts(v, replacer)]),\n    ) as ReplaceBigInts<T, type>;\n  return obj as ReplaceBigInts<T, type>;\n};\n", "export const contractDeployerAddress =\n  '0x0000000000000000000000000000000000008006' as const\n\nexport const contract2FactoryAddress =\n  '0x0000000000000000000000000000000000010000' as const\n\n/** The address of the L1 `ETH` token. */\nexport const legacyEthAddress =\n  '0x0000000000000000000000000000000000000000' as const\n\nexport const ethAddressInContracts =\n  '0x0000000000000000000000000000000000000001' as const\n\n/** The address of the base token. */\nexport const l2BaseTokenAddress =\n  '0x000000000000000000000000000000000000800a' as const\n\nexport const l1MessengerAddress =\n  '0x0000000000000000000000000000000000008008' as const\n\nexport const l1ToL2AliasOffset =\n  '0x1111000000000000000000000000000000001111' as const\n\nexport const addressModulo = 2n ** 160n\n", "import { hashBytecode } from \"viem/zksync\";\nimport type { Address } from \"../../../utils/address.js\";\nimport { toHex } from \"../../../utils/encoding/hex.js\";\nimport type {\n  EIP712SerializedTransaction,\n  EIP712TransactionOptions,\n} from \"../../prepare-transaction.js\";\nimport type { SerializableTransaction } from \"../../serialize-transaction.js\";\n\nexport type EIP721TransactionSerializable = SerializableTransaction & {\n  from: Address;\n} & EIP712TransactionOptions;\nexport const gasPerPubdataDefault = 50000n;\n\nexport const getEip712Domain = (transaction: EIP721TransactionSerializable) => {\n  const message = transactionToMessage(transaction);\n\n  return {\n    domain: {\n      name: \"zkSync\",\n      version: \"2\",\n      chainId: transaction.chainId,\n    },\n    types: {\n      Transaction: [\n        { name: \"txType\", type: \"uint256\" },\n        { name: \"from\", type: \"uint256\" },\n        { name: \"to\", type: \"uint256\" },\n        { name: \"gasLimit\", type: \"uint256\" },\n        { name: \"gasPerPubdataByteLimit\", type: \"uint256\" },\n        { name: \"maxFeePerGas\", type: \"uint256\" },\n        { name: \"maxPriorityFeePerGas\", type: \"uint256\" },\n        { name: \"paymaster\", type: \"uint256\" },\n        { name: \"nonce\", type: \"uint256\" },\n        { name: \"value\", type: \"uint256\" },\n        { name: \"data\", type: \"bytes\" },\n        { name: \"factoryDeps\", type: \"bytes32[]\" },\n        { name: \"paymasterInput\", type: \"bytes\" },\n      ],\n    },\n    primaryType: \"Transaction\",\n    message: message,\n  };\n};\n\nfunction transactionToMessage(\n  transaction: EIP721TransactionSerializable,\n): EIP712SerializedTransaction {\n  const {\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n    factoryDeps,\n  } = transaction;\n\n  return {\n    txType: 113n,\n    from: BigInt(from),\n    to: to ? BigInt(to) : 0n,\n    gasLimit: gas ?? 0n,\n    gasPerPubdataByteLimit: gasPerPubdata ?? gasPerPubdataDefault,\n    maxFeePerGas: maxFeePerGas ?? 0n,\n    maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,\n    paymaster: paymaster ? BigInt(paymaster) : 0n,\n    nonce: nonce ? BigInt(nonce) : 0n,\n    value: value ?? 0n,\n    data: data ? data : \"0x0\",\n    factoryDeps: factoryDeps?.map((dep) => toHex(hashBytecode(dep))) ?? [],\n    paymasterInput: paymasterInput ? paymasterInput : \"0x\",\n  };\n}\n", "import { hexToBytes, toRlp } from \"viem\";\nimport { eth_sendRawTransaction } from \"../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../rpc/rpc.js\";\nimport { type Address, getAddress } from \"../../../utils/address.js\";\nimport { replaceBigInts, toBigInt } from \"../../../utils/bigint.js\";\nimport { concatHex } from \"../../../utils/encoding/helpers/concat-hex.js\";\nimport { type Hex, toHex } from \"../../../utils/encoding/hex.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\nimport type { PreparedTransaction } from \"../../prepare-transaction.js\";\nimport { encode } from \"../encode.js\";\nimport { toSerializableTransaction } from \"../to-serializable-transaction.js\";\nimport type { WaitForReceiptOptions } from \"../wait-for-tx-receipt.js\";\nimport {\n  type EIP721TransactionSerializable,\n  gasPerPubdataDefault,\n  getEip712Domain,\n} from \"./getEip721Domain.js\";\n\ntype SendEip712TransactionOptions = {\n  account: Account;\n  // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n  transaction: PreparedTransaction<any>;\n};\n\n/**\n * Sends a transaction using the provided wallet.\n * @param options - The options for sending the transaction.\n * @returns A promise that resolves to the transaction hash.\n * @throws An error if the wallet is not connected.\n * @transaction\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction\n * });\n * ```\n */\nexport async function sendEip712Transaction(\n  options: SendEip712TransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  const { account, transaction } = options;\n\n  const eip712Transaction = await populateEip712Transaction(options);\n\n  const hash = await signEip712Transaction({\n    account,\n    eip712Transaction,\n    chainId: transaction.chain.id,\n  });\n\n  const rpc = getRpcClient(transaction);\n  const result = await eth_sendRawTransaction(rpc, hash);\n\n  return {\n    transactionHash: result,\n    chain: transaction.chain,\n    client: transaction.client,\n  };\n}\n\nexport async function signEip712Transaction(options: {\n  account: Account;\n  eip712Transaction: EIP721TransactionSerializable;\n  chainId: number;\n}): Promise<Hex> {\n  const { account, eip712Transaction, chainId } = options;\n  // EIP712 signing of the serialized tx\n  const eip712Domain = getEip712Domain(eip712Transaction);\n\n  const customSignature = await account.signTypedData({\n    // biome-ignore lint/suspicious/noExplicitAny: TODO type properly\n    ...(eip712Domain as any),\n  });\n\n  return serializeTransactionEIP712({\n    ...eip712Transaction,\n    chainId,\n    customSignature,\n  });\n}\n\n/**\n * Populate a prepared transaction to be serialized as a EIP712 transaction\n * @param options\n * @internal\n */\nexport async function populateEip712Transaction(\n  options: SendEip712TransactionOptions,\n): Promise<EIP721TransactionSerializable> {\n  const { account, transaction } = options;\n  const { gas, maxFeePerGas, maxPriorityFeePerGas, gasPerPubdata } =\n    await getZkGasFees({ transaction, from: getAddress(account.address) });\n\n  // serialize the transaction (with fees, gas, nonce)\n  const serializableTransaction = await toSerializableTransaction({\n    transaction: {\n      ...transaction,\n      gas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    },\n    from: account.address,\n  });\n\n  return {\n    ...serializableTransaction,\n    ...transaction.eip712,\n    gasPerPubdata,\n    from: account.address as Hex,\n  };\n}\n\nfunction serializeTransactionEIP712(\n  transaction: EIP721TransactionSerializable & {\n    chainId: number;\n    customSignature: Hex;\n  },\n): Hex {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    customSignature,\n    factoryDeps,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n  } = transaction;\n\n  const serializedTransaction = [\n    nonce ? toHex(nonce) : \"0x\",\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : \"0x\",\n    maxFeePerGas ? toHex(maxFeePerGas) : \"0x\",\n    gas ? toHex(gas) : \"0x\",\n    to ?? \"0x\",\n    value ? toHex(value) : \"0x\",\n    data ?? \"0x0\",\n    toHex(chainId),\n    toHex(\"\"),\n    toHex(\"\"),\n    toHex(chainId),\n    from ?? \"0x\",\n    gasPerPubdata ? toHex(gasPerPubdata) : toHex(gasPerPubdataDefault),\n    factoryDeps ?? [],\n    customSignature ?? \"0x\", // EIP712 signature\n    paymaster && paymasterInput ? [paymaster, paymasterInput] : [],\n  ];\n\n  // @ts-ignore - TODO: fix types\n  return concatHex([\"0x71\", toRlp(serializedTransaction)]);\n}\n\nexport async function getZkGasFees(args: {\n  transaction: PreparedTransaction;\n  from?: Address;\n}) {\n  const { transaction, from } = args;\n  let [gas, maxFeePerGas, maxPriorityFeePerGas, eip712] = await Promise.all([\n    resolvePromisedValue(transaction.gas),\n    resolvePromisedValue(transaction.maxFeePerGas),\n    resolvePromisedValue(transaction.maxPriorityFeePerGas),\n    resolvePromisedValue(transaction.eip712),\n  ]);\n  let gasPerPubdata = eip712?.gasPerPubdata;\n  if (\n    gas === undefined ||\n    maxFeePerGas === undefined ||\n    maxPriorityFeePerGas === undefined\n  ) {\n    const rpc = getRpcClient(transaction);\n    const params = await formatTransaction({ transaction, from });\n    const result = (await rpc({\n      // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n      method: \"zks_estimateFee\" as any,\n      // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n      params: [replaceBigInts(params, toHex)] as any,\n    })) as {\n      gas_limit: string;\n      max_fee_per_gas: string;\n      max_priority_fee_per_gas: string;\n      gas_per_pubdata_limit: string;\n    };\n    gas = toBigInt(result.gas_limit) * 2n; // overestimating to avoid issues when not accounting for paymaster extra gas ( we should really pass the paymaster input above for better accuracy )\n    const baseFee = toBigInt(result.max_fee_per_gas);\n    maxFeePerGas = baseFee * 2n; // bumping the base fee per gas to ensure fast inclusion\n    maxPriorityFeePerGas = toBigInt(result.max_priority_fee_per_gas) || 1n;\n    gasPerPubdata = toBigInt(result.gas_per_pubdata_limit) * 2n; // doubling for fast inclusion;\n    if (gasPerPubdata < 50000n) {\n      // enforce a minimum gas per pubdata limit\n      gasPerPubdata = 50000n;\n    }\n  }\n  return {\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    gasPerPubdata,\n  };\n}\n\nasync function formatTransaction(args: {\n  transaction: PreparedTransaction;\n  from?: Address;\n}) {\n  const { transaction, from } = args;\n  const [data, to, value, eip712] = await Promise.all([\n    encode(transaction),\n    resolvePromisedValue(transaction.to),\n    resolvePromisedValue(transaction.value),\n    resolvePromisedValue(transaction.eip712),\n  ]);\n  const gasPerPubdata = eip712?.gasPerPubdata;\n  return {\n    from,\n    to,\n    data,\n    value,\n    gasPerPubdata,\n    eip712Meta: {\n      ...eip712,\n      gasPerPubdata: gasPerPubdata || 50000n,\n      factoryDeps: eip712?.factoryDeps?.map((dep) =>\n        Array.from(hexToBytes(dep)),\n      ),\n    },\n    type: \"0x71\",\n  };\n}\n"],
  "mappings": "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",
  "names": ["getEip712Domain", "sendEip712Transaction", "signEip712Transaction", "getEip712Domain"]
}
