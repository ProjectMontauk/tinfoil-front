{
  "version": 3,
  "sources": ["../../thirdweb/src/utils/hashing/sha256.ts", "../../thirdweb/src/utils/client-id.ts", "../../thirdweb/src/client/client.ts", "../../thirdweb/src/rpc/actions/eth_getBlockByHash.ts", "../../thirdweb/src/rpc/actions/eth_getTransactionByHash.ts", "../../thirdweb/src/bridge/index.ts", "../../thirdweb/src/bridge/Buy.ts", "../../thirdweb/src/bridge/constants.ts", "../../thirdweb/src/bridge/Sell.ts", "../../thirdweb/src/bridge/Status.ts", "../../thirdweb/src/bridge/Routes.ts", "../../thirdweb/src/bridge/Chains.ts", "../../thirdweb/src/engine/index.ts", "../../@thirdweb-dev/engine/src/client/client.gen.ts", "../../@thirdweb-dev/engine/src/client/sdk.gen.ts", "../../thirdweb/src/engine/get-status.ts", "../../thirdweb/src/engine/server-wallet.ts", "../../thirdweb/src/wallets/in-app/core/users/getUser.ts", "../../thirdweb/src/transaction/resolve-method.ts", "../../ox/core/internal/entropy.ts", "../../ox/core/Secp256k1.ts", "../../thirdweb/src/transaction/actions/sign-transaction.ts", "../../thirdweb/src/auth/verify-typed-data.ts", "../../thirdweb/src/transaction/actions/eip7702/authorization.ts"],
  "sourcesContent": ["import { sha256 as noble_sha256 } from \"@noble/hashes/sha256\";\nimport {\n  type Hex,\n  hexToUint8Array,\n  isHex,\n  uint8ArrayToHex,\n} from \"../encoding/hex.js\";\n\ntype To = \"hex\" | \"bytes\";\n\ntype Sha256Hash<TTo extends To> =\n  | (TTo extends \"bytes\" ? Uint8Array : never)\n  | (TTo extends \"hex\" ? Hex : never);\n\n/**\n * Calculates the SHA256 hash of the given value.\n * @param value - The value to hash. It can be either a hexadecimal string or a Uint8Array.\n * @param to - (Optional) The desired output format of the hash. Defaults to 'hex'.\n * @returns The SHA256 hash of the value in the specified format.\n * @example\n * ```ts\n * import { sha256 } from \"thirdweb/utils\";\n * const hash = sha256(\"0x1234\");\n * ```\n * @utils\n */\nexport function sha256<TTo extends To = \"hex\">(\n  value: Hex | Uint8Array,\n  to?: TTo,\n): Sha256Hash<TTo> {\n  const bytes = noble_sha256(\n    isHex(value, { strict: false }) ? hexToUint8Array(value) : value,\n  );\n  if (to === \"bytes\") {\n    return bytes as Sha256Hash<TTo>;\n  }\n  return uint8ArrayToHex(bytes) as Sha256Hash<TTo>;\n}\n", "import { LruMap } from \"./caching/lru.js\";\nimport { stringToBytes } from \"./encoding/to-bytes.js\";\nimport { sha256 } from \"./hashing/sha256.js\";\n\nconst cache = new LruMap<string>(4096);\n\n/**\n * @param secretKey - the secret key to compute the client id from\n * @returns the 32 char hex client id\n * @internal\n */\nexport function computeClientIdFromSecretKey(secretKey: string): string {\n  if (cache.has(secretKey)) {\n    return cache.get(secretKey) as string;\n  }\n  // we slice off the leading `0x` and then take the first 32 chars\n  const cId = sha256(stringToBytes(secretKey)).slice(2, 34);\n  cache.set(secretKey, cId);\n  return cId;\n}\n", "import { computeClientIdFromSecretKey } from \"../utils/client-id.js\";\nimport { isJWT } from \"../utils/jwt/is-jwt.js\";\nimport type { Prettify } from \"../utils/type-utils.js\";\n\ntype FetchConfig = {\n  requestTimeoutMs?: number;\n  keepalive?: boolean;\n  headers?: HeadersInit;\n};\n\ntype ClientOptions = Prettify<{\n  /**\n   * The configuration options for the client.\n   */\n  config?: {\n    /**\n     * The configuration options for the RPC client.\n     */\n    rpc?: {\n      /**\n       * The configuration options for the fetch function.\n       * @default {}\n       */\n      fetch?: FetchConfig;\n      /**\n       * The maximum number of requests to batch together.\n       * @default 100\n       */\n      maxBatchSize?: number;\n      /**\n       * The maximum time to wait before sending a batch of requests.\n       * @default 0 (no timeout)\n       */\n      batchTimeoutMs?: number;\n    };\n    /**\n     * The configuration options for the storage client.\n     */\n    storage?: {\n      /**\n       * The configuration options for the fetch function.\n       * @default {}\n       */\n      fetch?: FetchConfig;\n      /**\n       * The IPFS gateway URL.\n       * @default \"https://<your_client_id>.ipfscdn.io/ipfs/<cid>\"\n       */\n      gatewayUrl?: string;\n    };\n  };\n\n  /**\n   * The team ID for thirdweb dashboard usage.\n   * @hidden\n   */\n  teamId?: string;\n}>;\n\nexport type CreateThirdwebClientOptions = Prettify<\n  (\n    | {\n        clientId: string;\n        secretKey?: string;\n      }\n    | {\n        clientId?: string;\n        secretKey: string;\n      }\n  ) &\n    ClientOptions\n>;\n\nexport type ThirdwebClient = {\n  readonly clientId: string;\n  readonly secretKey: string | undefined;\n} & Readonly<ClientOptions>;\n\n/**\n * Creates a Thirdweb client using the provided client ID (client-side) or secret key (server-side).\n *\n * Get your client ID and secret key from the Thirdweb dashboard [here](https://thirdweb.com/create-api-key).\n * **Never share your secret key with anyone.\n *\n * A client is necessary for most functions in the thirdweb SDK. It provides access to thirdweb APIs including built-in RPC, storage, and more.\n *\n * @param options - The options for creating the client.\n * @param [options.clientId] - The client ID to use for thirdweb services.\n * @param [options.secretKey] - The secret key to use for thirdweb services.\n * @returns The created Thirdweb client.\n * @throws An error if neither `clientId` nor `secretKey` is provided.\n *\n * @example\n * Create a client on the client side (client ID):\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n *\n * const client = createThirdwebClient({ clientId: \"...\" });\n * ```\n *\n * Create a client on the server (secret key):\n * ```ts\n * import { createThirdwebClient } from \"thirdweb\";\n *\n * const client = createThirdwebClient({ secretKey: \"...\" });\n * ```\n * @client\n */\nexport function createThirdwebClient(\n  options: CreateThirdwebClientOptions,\n): ThirdwebClient {\n  const { clientId, secretKey, ...rest } = options;\n\n  let realClientId: string | undefined = clientId;\n\n  if (secretKey) {\n    if (isJWT(secretKey)) {\n      // when passing a JWT as secret key we HAVE to also have a clientId\n      if (!clientId) {\n        throw new Error(\"clientId must be provided when using a JWT secretKey\");\n      }\n    } else {\n      // always PREFER the clientId if provided, only compute it from the secretKey if we don't have a clientId passed explicitly\n      realClientId = clientId ?? computeClientIdFromSecretKey(secretKey);\n    }\n  }\n\n  // only path we get here is if we have no secretKey and no clientId\n  if (!realClientId) {\n    throw new Error(\"clientId or secretKey must be provided\");\n  }\n\n  return {\n    ...rest,\n    clientId: realClientId,\n    secretKey,\n  } as const;\n}\n", "import {\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  type GetBlockReturnType,\n  type Hash,\n  formatBlock,\n} from \"viem\";\n\ntype GetBlockByHashParams<TIncludeTransactions extends boolean = false> = {\n  /** Whether or not to include transaction data in the response. */\n  includeTransactions?: TIncludeTransactions;\n} & {\n  /** Hash of the block. */\n  blockHash: Hash;\n};\n\n/**\n * Retrieves a block by its hash.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for the block retrieval.\n * @returns A promise that resolves to the retrieved block.\n * @throws An error if the block is not found.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getBlockByHash } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const block = await eth_getBlockByHash(rpcRequest, {\n * blockHash: \"0x...\",\n * includeTransactions: true,\n * });\n * ```\n */\nexport async function eth_getBlockByHash<\n  TIncludeTransactions extends boolean = false,\n>(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetBlockByHashParams<TIncludeTransactions>,\n): Promise<GetBlockReturnType<undefined, TIncludeTransactions>> {\n  const includeTransactions = params.includeTransactions ?? false;\n\n  const block = await request({\n    method: \"eth_getBlockByHash\",\n    params: [params.blockHash, includeTransactions],\n  });\n  if (!block) {\n    throw new Error(\"Block not found\");\n  }\n  return formatBlock(block) as GetBlockReturnType<\n    undefined,\n    TIncludeTransactions\n  >;\n}\n", "import {\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  type Hash,\n  type Transaction,\n  formatTransaction,\n} from \"viem\";\n\ntype GetTransactionByHashParameters = {\n  hash: Hash;\n};\n\n/**\n * Retrieves a transaction by its hash.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for retrieving the transaction.\n * @returns A promise that resolves to the transaction.\n * @throws An error if the transaction is not found.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getTransactionByHash } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n *  const transaction = await eth_getTransactionByHash(rpcRequest, {\n *  hash: \"0x...\",\n * });\n * ```\n */\nexport async function eth_getTransactionByHash(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetTransactionByHashParameters,\n): Promise<Transaction> {\n  const receipt = await request({\n    method: \"eth_getTransactionByHash\",\n    params: [params.hash],\n  });\n\n  if (!receipt) {\n    throw new Error(\"Transaction not found.\");\n  }\n\n  return formatTransaction(receipt);\n}\n", "export * as Buy from \"./Buy.js\";\nexport * as Sell from \"./Sell.js\";\nexport { status } from \"./Status.js\";\nexport { routes } from \"./Routes.js\";\nexport { chains } from \"./Chains.js\";\n\nexport type { Status } from \"./types/Status.js\";\nexport type { Route } from \"./types/Route.js\";\nexport type { Quote, PreparedQuote } from \"./types/Quote.js\";\nexport type { Chain } from \"./types/Chain.js\";\n", "import type { Address as ox__Address } from \"ox\";\nimport { defineChain } from \"../chains/utils.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { stringify } from \"../utils/json.js\";\nimport { UNIVERSAL_BRIDGE_URL } from \"./constants.js\";\nimport type { PreparedQuote, Quote } from \"./types/Quote.js\";\n\n/**\n * Retrieves a Universal Bridge quote for the provided buy intent. The quote will specify the necessary `originAmount` to receive the desired `destinationAmount`, which is specified with the `buyAmountWei` option.\n *\n * @example\n * ```typescript\n * import { Bridge, NATIVE_TOKEN_ADDRESS } from \"thirdweb\";\n *\n * const quote = await Bridge.Buy.quote({\n *   originChainId: 1,\n *   originTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   destinationChainId: 10,\n *   destinationTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   amount: toWei(\"0.01\"),\n *   client: thirdwebClient,\n * });\n * ```\n *\n * This will return a quote that might look like:\n * ```typescript\n * {\n *   originAmount: 10000026098875381n,\n *   destinationAmount: 1000000000000000000n,\n *   blockNumber: 22026509n,\n *   timestamp: 1741730936680,\n *   estimatedExecutionTimeMs: 1000\n *   steps: [\n *     {\n *       originToken: {\n *         chainId: 1,\n *         address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *         symbol: \"ETH\",\n *         name: \"Ethereum\",\n *         decimals: 18,\n *         priceUsd: 0.0025,\n *         iconUri: \"https://...\"\n *       },\n *       destinationToken: {\n *         chainId: 10,\n *         address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *         symbol: \"ETH\",\n *         name: \"Ethereum\",\n *         decimals: 18,\n *         priceUsd: 0.0025,\n *         iconUri: \"https://...\"\n *       },\n *       originAmount: 10000026098875381n,\n *       destinationAmount: 1000000000000000000n,\n *       estimatedExecutionTimeMs: 1000\n *     }\n *   ],\n *   intent: {\n *     originChainId: 1,\n *     originTokenAddress: NATIVE_TOKEN_ADDRESS,\n *     destinationChainId: 10,\n *     destinationTokenAddress: NATIVE_TOKEN_ADDRESS,\n *     amount: 1000000000000000000n\n *   }\n * }\n * ```\n *\n * The quote is an **estimate** for how much you would expect to pay for a specific buy. This quote is not guaranteed and you should use `Buy.prepare` to get a finalized quote with transaction data ready for execution.\n * So why use `quote`? The quote function is sometimes slightly faster than `prepare`, and can be used before the user connects their wallet.\n *\n * You can access this functions input and output types with `Buy.quote.Options` and `Buy.quote.Result`, respectively.\n *\n * To limit quotes to routes that have a certain number of steps involved, use the `maxSteps` option.\n *\n * ```ts\n * const quote = await Bridge.Buy.quote({\n *   originChainId: 1,\n *   originTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   destinationChainId: 10,\n *   destinationTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   amount: toWei(\"0.01\"),\n *   maxSteps: 2, // Will only return a quote for routes with 2 or fewer steps\n *   client: thirdwebClient,\n * });\n * ```\n *\n * @param options - The options for the quote.\n * @param options.originChainId - The chain ID of the origin token.\n * @param options.originTokenAddress - The address of the origin token.\n * @param options.destinationChainId - The chain ID of the destination token.\n * @param options.destinationTokenAddress - The address of the destination token.\n * @param options.amount - The amount of the destination token to receive.\n * @param [options.maxSteps] - Limit the number of total steps in the route.\n * @param options.client - Your thirdweb client.\n *\n * @returns A promise that resolves to a non-finalized quote for the requested buy.\n *\n * @throws Will throw an error if there is an issue fetching the quote.\n * @bridge Buy\n * @beta\n */\nexport async function quote(options: quote.Options): Promise<quote.Result> {\n  const {\n    originChainId,\n    originTokenAddress,\n    destinationChainId,\n    destinationTokenAddress,\n    client,\n    maxSteps,\n  } = options;\n  const amount =\n    \"buyAmountWei\" in options ? options.buyAmountWei : options.amount;\n\n  const clientFetch = getClientFetch(client);\n  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/buy/quote`);\n  url.searchParams.set(\"originChainId\", originChainId.toString());\n  url.searchParams.set(\"originTokenAddress\", originTokenAddress);\n  url.searchParams.set(\"destinationChainId\", destinationChainId.toString());\n  url.searchParams.set(\"destinationTokenAddress\", destinationTokenAddress);\n  url.searchParams.set(\"buyAmountWei\", amount.toString());\n  if (maxSteps) {\n    url.searchParams.set(\"maxSteps\", maxSteps.toString());\n  }\n\n  const response = await clientFetch(url.toString());\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new Error(\n      `${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`,\n    );\n  }\n\n  const { data }: { data: Quote } = await response.json();\n  return {\n    originAmount: BigInt(data.originAmount),\n    destinationAmount: BigInt(data.destinationAmount),\n    blockNumber: data.blockNumber ? BigInt(data.blockNumber) : undefined,\n    timestamp: data.timestamp,\n    estimatedExecutionTimeMs: data.estimatedExecutionTimeMs,\n    steps: data.steps,\n    intent: {\n      originChainId,\n      originTokenAddress,\n      destinationChainId,\n      destinationTokenAddress,\n      buyAmountWei: amount,\n      amount,\n    },\n  };\n}\n\nexport declare namespace quote {\n  type Options = {\n    originChainId: number;\n    originTokenAddress: ox__Address.Address;\n    destinationChainId: number;\n    destinationTokenAddress: ox__Address.Address;\n    client: ThirdwebClient;\n    maxSteps?: number;\n  } & (\n    | {\n        buyAmountWei: bigint;\n      }\n    | {\n        amount: bigint;\n      }\n  );\n\n  type Result = Quote & {\n    intent: {\n      originChainId: number;\n      originTokenAddress: ox__Address.Address;\n      destinationChainId: number;\n      destinationTokenAddress: ox__Address.Address;\n      buyAmountWei: bigint;\n      amount: bigint;\n    };\n  };\n}\n\n/**\n * Prepares a **finalized** Universal Bridge quote for the provided buy request with transaction data. This function will return everything `quote` does, with the addition of a series of prepared transactions and the associated expiration timestamp.\n *\n * @example\n * ```typescript\n * import { Bridge, NATIVE_TOKEN_ADDRESS } from \"thirdweb\";\n *\n * const quote = await Bridge.Buy.prepare({\n *   originChainId: 1,\n *   originTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   destinationChainId: 10,\n *   destinationTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   amount: toWei(\"0.01\"),\n *   client: thirdwebClient,\n * });\n * ```\n *\n * This will return a quote that might look like:\n * ```typescript\n * {\n *   originAmount: 10000026098875381n,\n *   destinationAmount: 1000000000000000000n,\n *   blockNumber: 22026509n,\n *   timestamp: 1741730936680,\n *   estimatedExecutionTimeMs: 1000\n *   steps: [\n *     {\n *       originToken: {\n *         chainId: 1,\n *         address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *         symbol: \"ETH\",\n *         name: \"Ethereum\",\n *         decimals: 18,\n *         priceUsd: 2000,\n *         iconUri: \"https://...\"\n *       },\n *       destinationToken: {\n *         chainId: 10,\n *         address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *         symbol: \"ETH\",\n *         name: \"Ethereum\",\n *         decimals: 18,\n *         priceUsd: 2000,\n *         iconUri: \"https://...\"\n *       },\n *       originAmount: 10000026098875381n,\n *       destinationAmount: 1000000000000000000n,\n *       estimatedExecutionTimeMs: 1000\n *       transactions: [\n *         {\n *           action: \"approval\",\n *           id: \"0x\",\n *           to: \"0x...\",\n *           data: \"0x...\",\n *           chainId: 10,\n *           type: \"eip1559\"\n *         },\n *         {\n *           action: \"buy\",\n *           to: \"0x...\",\n *           value: 10000026098875381n,\n *           data: \"0x...\",\n *           chainId: 10,\n *           type: \"eip1559\"\n *         }\n *       ]\n *     }\n *   ],\n *   expiration: 1741730936680,\n *   intent: {\n *     originChainId: 1,\n *     originTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *     destinationChainId: 10,\n *     destinationTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *     amount: 1000000000000000000n\n *   }\n * }\n * ```\n *\n * ## Sending the transactions\n * The `transactions` array is a series of [ox](https://oxlib.sh) EIP-1559 transactions that must be executed one after the other in order to fulfill the complete route. There are a few things to keep in mind when executing these transactions:\n *  - Approvals will have the `approval` action specified. You can perform approvals with `sendAndConfirmTransaction`, then proceed to the next transaction.\n *  - All transactions are assumed to be executed by the `sender` address, regardless of which chain they are on. The final transaction will use the `receiver` as the recipient address.\n *  - If an `expiration` timestamp is provided, all transactions must be executed before that time to guarantee successful execution at the specified price.\n *\n * NOTE: To get the status of each non-approval transaction, use `Bridge.status` rather than checking for transaction inclusion. This function will ensure full bridge completion on the destination chain.\n *\n * You can access this functions input and output types with `Buy.prepare.Options` and `Buy.prepare.Result`, respectively.\n *\n * You can include arbitrary data to be included on any webhooks and status responses with the `purchaseData` option.\n *\n * ```ts\n * const quote = await Bridge.Buy.prepare({\n *   originChainId: 1,\n *   originTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   destinationChainId: 10,\n *   destinationTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   amount: toWei(\"0.01\"),\n *   purchaseData: {\n *     size: \"large\",\n *     shippingAddress: \"123 Main St, New York, NY 10001\",\n *   },\n *   client: thirdwebClient,\n * });\n * ```\n *\n * To limit quotes to routes that have a certain number of steps involved, use the `maxSteps` option.\n *\n * ```ts\n * const quote = await Bridge.Buy.prepare({\n *   originChainId: 1,\n *   originTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   destinationChainId: 10,\n *   destinationTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   amount: toWei(\"0.01\"),\n *   maxSteps: 2, // Will only return a quote for routes with 2 or fewer steps\n *   client: thirdwebClient,\n * });\n * ```\n *\n * @param options - The options for the quote.\n * @param options.originChainId - The chain ID of the origin token.\n * @param options.originTokenAddress - The address of the origin token.\n * @param options.destinationChainId - The chain ID of the destination token.\n * @param options.destinationTokenAddress - The address of the destination token.\n * @param options.amount - The amount of the destination token to receive.\n * @param options.sender - The address of the sender.\n * @param options.receiver - The address of the recipient.\n * @param options.purchaseData - Arbitrary data to be passed to the purchase function and included with any webhooks or status calls.\n * @param [options.maxSteps] - Limit the number of total steps in the route.\n * @param options.client - Your thirdweb client.\n *\n * @returns A promise that resolves to a finalized quote and transactions for the requested buy.\n *\n * @throws Will throw an error if there is an issue fetching the quote.\n * @bridge Buy\n * @beta\n */\nexport async function prepare(\n  options: prepare.Options,\n): Promise<prepare.Result> {\n  const {\n    originChainId,\n    originTokenAddress,\n    destinationChainId,\n    destinationTokenAddress,\n    sender,\n    receiver,\n    client,\n    amount,\n    purchaseData,\n    maxSteps,\n  } = options;\n\n  const clientFetch = getClientFetch(client);\n  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/buy/prepare`);\n\n  const response = await clientFetch(url.toString(), {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify({\n      buyAmountWei: amount.toString(),\n      originChainId: originChainId.toString(),\n      originTokenAddress,\n      destinationChainId: destinationChainId.toString(),\n      destinationTokenAddress,\n      sender,\n      receiver,\n      purchaseData,\n      maxSteps,\n    }),\n  });\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new Error(\n      `${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`,\n    );\n  }\n\n  const { data }: { data: PreparedQuote } = await response.json();\n  return {\n    originAmount: BigInt(data.originAmount),\n    destinationAmount: BigInt(data.destinationAmount),\n    blockNumber: data.blockNumber ? BigInt(data.blockNumber) : undefined,\n    timestamp: data.timestamp,\n    estimatedExecutionTimeMs: data.estimatedExecutionTimeMs,\n    steps: data.steps.map((step) => ({\n      ...step,\n      transactions: step.transactions.map((transaction) => ({\n        ...transaction,\n        value: transaction.value ? BigInt(transaction.value) : undefined,\n        client,\n        chain: defineChain(transaction.chainId),\n      })),\n    })),\n    intent: {\n      originChainId,\n      originTokenAddress,\n      destinationChainId,\n      destinationTokenAddress,\n      amount,\n    },\n  };\n}\n\nexport declare namespace prepare {\n  type Options = {\n    originChainId: number;\n    originTokenAddress: ox__Address.Address;\n    destinationChainId: number;\n    destinationTokenAddress: ox__Address.Address;\n    sender: ox__Address.Address;\n    receiver: ox__Address.Address;\n    amount: bigint;\n    client: ThirdwebClient;\n    purchaseData?: unknown;\n    maxSteps?: number;\n  };\n\n  type Result = PreparedQuote & {\n    intent: {\n      originChainId: number;\n      originTokenAddress: ox__Address.Address;\n      destinationChainId: number;\n      destinationTokenAddress: ox__Address.Address;\n      amount: bigint;\n      purchaseData?: unknown;\n    };\n  };\n}\n", "export const UNIVERSAL_BRIDGE_URL = \"https://bridge.thirdweb.com/v1\";\n", "import type { Address as ox__Address } from \"ox\";\nimport { defineChain } from \"../chains/utils.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { stringify } from \"../utils/json.js\";\nimport { UNIVERSAL_BRIDGE_URL } from \"./constants.js\";\nimport type { PreparedQuote, Quote } from \"./types/Quote.js\";\n\n/**\n * Retrieves a Universal Bridge quote for the provided sell intent. The quote will specify the expected `destinationAmount` that will be received in exchange for the specified `originAmount`, which is specified with the `sellAmountWei` option.\n *\n * @example\n * ```typescript\n * import { Bridge, NATIVE_TOKEN_ADDRESS } from \"thirdweb\";\n *\n * const quote = await Bridge.Sell.quote({\n *   originChainId: 1,\n *   originTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   destinationChainId: 10,\n *   destinationTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   amount: toWei(\"0.01\"),\n *   client: thirdwebClient,\n * });\n * ```\n *\n * This will return a quote that might look like:\n * ```typescript\n * {\n *   originAmount: 1000000000000000000n,\n *   destinationAmount: 9999979011973735n,\n *   blockNumber: 22026509n,\n *   timestamp: 1741730936680,\n *   estimatedExecutionTimeMs: 1000\n *   steps: [\n *     {\n *       originToken: {\n *         chainId: 1,\n *         address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *         symbol: \"ETH\",\n *         name: \"Ethereum\",\n *         decimals: 18,\n *         priceUsd: 2000,\n *         iconUri: \"https://...\"\n *       },\n *       destinationToken: {\n *         chainId: 10,\n *         address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *         symbol: \"ETH\",\n *         name: \"Ethereum\",\n *         decimals: 18,\n *         priceUsd: 2000,\n *         iconUri: \"https://...\"\n *       },\n *       originAmount: 1000000000000000000n,\n *       destinationAmount:  99999979011973735n,\n *       estimatedExecutionTimeMs: 1000\n *     }\n *   ],\n *   intent: {\n *     originChainId: 1,\n *     originTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *     destinationChainId: 10,\n *     destinationTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *     amount: 1000000000000000000n\n *   }\n * }\n * ```\n *\n * The quote is an **estimate** for how much you would expect to receive for a specific sell. This quote is not guaranteed and you should use `Sell.prepare` to get a finalized quote with transaction data ready for execution.\n * So why use `quote`? The quote function is sometimes slightly faster than `prepare`, and can be used before the user connects their wallet.\n *\n * You can access this functions input and output types with `Sell.quote.Options` and `Sell.quote.Result`, respectively.\n *\n * To limit quotes to routes that have a certain number of steps involved, use the `maxSteps` option.\n *\n * ```ts\n * const quote = await Bridge.Sell.quote({\n *   originChainId: 1,\n *   originTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   destinationChainId: 10,\n *   destinationTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   amount: toWei(\"0.01\"),\n *   maxSteps: 2, // Will only return a quote for routes with 2 or fewer steps\n *   client: thirdwebClient,\n * });\n * ```\n *\n * @param options - The options for the quote.\n * @param options.originChainId - The chain ID of the origin token.\n * @param options.originTokenAddress - The address of the origin token.\n * @param options.destinationChainId - The chain ID of the destination token.\n * @param options.destinationTokenAddress - The address of the destination token.\n * @param options.amount - The amount of the origin token to sell.\n * @param [options.maxSteps] - Limit the number of total steps in the route.\n * @param options.client - Your thirdweb client.\n *\n * @returns A promise that resolves to a non-finalized quote for the requested sell.\n *\n * @throws Will throw an error if there is an issue fetching the quote.\n * @bridge Sell\n * @beta\n */\nexport async function quote(options: quote.Options): Promise<quote.Result> {\n  const {\n    originChainId,\n    originTokenAddress,\n    destinationChainId,\n    destinationTokenAddress,\n    amount,\n    client,\n    maxSteps,\n  } = options;\n\n  const clientFetch = getClientFetch(client);\n  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/sell/quote`);\n  url.searchParams.set(\"originChainId\", originChainId.toString());\n  url.searchParams.set(\"originTokenAddress\", originTokenAddress);\n  url.searchParams.set(\"destinationChainId\", destinationChainId.toString());\n  url.searchParams.set(\"destinationTokenAddress\", destinationTokenAddress);\n  url.searchParams.set(\"sellAmountWei\", amount.toString());\n  if (typeof maxSteps !== \"undefined\") {\n    url.searchParams.set(\"maxSteps\", maxSteps.toString());\n  }\n\n  const response = await clientFetch(url.toString());\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new Error(\n      `${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`,\n    );\n  }\n\n  const { data }: { data: Quote } = await response.json();\n  return {\n    originAmount: BigInt(data.originAmount),\n    destinationAmount: BigInt(data.destinationAmount),\n    blockNumber: data.blockNumber ? BigInt(data.blockNumber) : undefined,\n    timestamp: data.timestamp,\n    estimatedExecutionTimeMs: data.estimatedExecutionTimeMs,\n    steps: data.steps,\n    intent: {\n      originChainId,\n      originTokenAddress,\n      destinationChainId,\n      destinationTokenAddress,\n      amount,\n    },\n  };\n}\n\nexport declare namespace quote {\n  type Options = {\n    originChainId: number;\n    originTokenAddress: ox__Address.Address;\n    destinationChainId: number;\n    destinationTokenAddress: ox__Address.Address;\n    amount: bigint;\n    client: ThirdwebClient;\n    maxSteps?: number;\n  };\n\n  type Result = Quote & {\n    intent: {\n      originChainId: number;\n      originTokenAddress: ox__Address.Address;\n      destinationChainId: number;\n      destinationTokenAddress: ox__Address.Address;\n      amount: bigint;\n    };\n  };\n}\n\n/**\n * Prepares a **finalized** Universal Bridge quote for the provided sell request with transaction data. This function will return everything `quote` does, with the addition of a series of prepared transactions and the associated expiration timestamp.\n *\n * @example\n * ```typescript\n * import { Bridge, NATIVE_TOKEN_ADDRESS } from \"thirdweb\";\n *\n * const quote = await Bridge.Sell.prepare({\n *   originChainId: 1,\n *   originTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   destinationChainId: 10,\n *   destinationTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   amount: toWei(\"0.01\"),\n *   client: thirdwebClient,\n * });\n * ```\n *\n * This will return a quote that might look like:\n * ```typescript\n * {\n *   originAmount: 1000000000000000000n,\n *   destinationAmount:  9980000000000000000n,\n *   blockNumber: 22026509n,\n *   timestamp: 1741730936680,\n *   estimatedExecutionTimeMs: 1000\n *   steps: [\n *     {\n *       originToken: {\n *         chainId: 1,\n *         address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *         symbol: \"ETH\",\n *         name: \"Ethereum\",\n *         decimals: 18,\n *         priceUsd: 2000,\n *         iconUri: \"https://...\"\n *       },\n *       destinationToken: {\n *         chainId: 10,\n *         address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *         symbol: \"ETH\",\n *         name: \"Ethereum\",\n *         decimals: 18,\n *         priceUsd: 2000,\n *         iconUri: \"https://...\"\n *       },\n *       originAmount: 1000000000000000000n,\n *       destinationAmount:  9980000000000000000n,\n *       estimatedExecutionTimeMs: 1000\n *     }\n *     transactions: [\n *       {\n *         id: \"0x...\",\n *         action: \"approval\",\n *         to: \"0x...\",\n *         data: \"0x...\",\n *         chainId: 10,\n *         type: \"eip1559\"\n *       },\n *       {\n *         id: \"0x...\",\n *         action: \"sell\",\n *         to: \"0x...\",\n *         data: \"0x...\",\n *         chainId: 10,\n *         type: \"eip1559\"\n *       }\n *     ],\n *   ],\n *   expiration: 1741730936680,\n *   intent: {\n *     originChainId: 1,\n *     originTokenAddress: NATIVE_TOKEN_ADDRESS,\n *     destinationChainId: 10,\n *     destinationTokenAddress: NATIVE_TOKEN_ADDRESS,\n *     amount: 1000000000000000000n\n *   }\n * }\n * ```\n *\n * ## Sending the transactions\n * The `transactions` array is a series of [ox](https://oxlib.sh) EIP-1559 transactions that must be executed one after the other in order to fulfill the complete route. There are a few things to keep in mind when executing these transactions:\n *  - Approvals will have the `approval` action specified. You can perform approvals with `sendAndConfirmTransaction`, then proceed to the next transaction.\n *  - All transactions are assumed to be executed by the `sender` address, regardless of which chain they are on. The final transaction will use the `receiver` as the recipient address.\n *  - If an `expiration` timestamp is provided, all transactions must be executed before that time to guarantee successful execution at the specified price.\n *\n * NOTE: To get the status of each non-approval transaction, use `Bridge.status` rather than checking for transaction inclusion. This function will ensure full bridge completion on the destination chain.\n *\n * You can access this functions input and output types with `Sell.prepare.Options` and `Sell.prepare.Result`, respectively.\n *\n * You can include arbitrary data to be included on any webhooks and status responses with the `purchaseData` option.\n *\n * ```ts\n * const quote = await Bridge.Sell.prepare({\n *   originChainId: 1,\n *   originTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   destinationChainId: 10,\n *   destinationTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   amount: toWei(\"0.01\"),\n *   purchaseData: {\n *     size: \"large\",\n *     shippingAddress: \"123 Main St, New York, NY 10001\",\n *   },\n *   client: thirdwebClient,\n * });\n * ```\n *\n * To limit quotes to routes that have a certain number of steps involved, use the `maxSteps` option.\n *\n * ```ts\n * const quote = await Bridge.Sell.prepare({\n *   originChainId: 1,\n *   originTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   destinationChainId: 10,\n *   destinationTokenAddress: NATIVE_TOKEN_ADDRESS,\n *   amount: toWei(\"0.01\"),\n *   maxSteps: 2, // Will only return a quote for routes with 2 or fewer steps\n *   client: thirdwebClient,\n * });\n * ```\n *\n * @param options - The options for the quote.\n * @param options.originChainId - The chain ID of the origin token.\n * @param options.originTokenAddress - The address of the origin token.\n * @param options.destinationChainId - The chain ID of the destination token.\n * @param options.destinationTokenAddress - The address of the destination token.\n * @param options.amount - The amount of the origin token to sell.\n * @param options.sender - The address of the sender.\n * @param options.receiver - The address of the recipient.\n * @param options.purchaseData - Arbitrary data to be passed to the purchase function and included with any webhooks or status calls.\n * @param [options.maxSteps] - Limit the number of total steps in the route.\n * @param options.client - Your thirdweb client.\n *\n * @returns A promise that resolves to a finalized quote and transactions for the requested sell.\n *\n * @throws Will throw an error if there is an issue fetching the quote.\n * @bridge Sell\n * @beta\n */\nexport async function prepare(\n  options: prepare.Options,\n): Promise<prepare.Result> {\n  const {\n    originChainId,\n    originTokenAddress,\n    destinationChainId,\n    destinationTokenAddress,\n    amount,\n    sender,\n    receiver,\n    client,\n    purchaseData,\n    maxSteps,\n  } = options;\n\n  const clientFetch = getClientFetch(client);\n  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/sell/prepare`);\n\n  const response = await clientFetch(url.toString(), {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify({\n      sellAmountWei: amount.toString(),\n      originChainId: originChainId.toString(),\n      originTokenAddress,\n      destinationChainId: destinationChainId.toString(),\n      destinationTokenAddress,\n      sender,\n      receiver,\n      purchaseData,\n      maxSteps,\n    }),\n  });\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new Error(\n      `${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`,\n    );\n  }\n\n  const { data }: { data: PreparedQuote } = await response.json();\n  return {\n    originAmount: BigInt(data.originAmount),\n    destinationAmount: BigInt(data.destinationAmount),\n    blockNumber: data.blockNumber ? BigInt(data.blockNumber) : undefined,\n    timestamp: data.timestamp,\n    estimatedExecutionTimeMs: data.estimatedExecutionTimeMs,\n    steps: data.steps.map((step) => ({\n      ...step,\n      transactions: step.transactions.map((transaction) => ({\n        ...transaction,\n        value: transaction.value ? BigInt(transaction.value) : undefined,\n        client,\n        chain: defineChain(transaction.chainId),\n      })),\n    })),\n    expiration: data.expiration,\n    intent: {\n      originChainId,\n      originTokenAddress,\n      destinationChainId,\n      destinationTokenAddress,\n      amount,\n      purchaseData,\n    },\n  };\n}\n\nexport declare namespace prepare {\n  type Options = {\n    originChainId: number;\n    originTokenAddress: ox__Address.Address;\n    destinationChainId: number;\n    destinationTokenAddress: ox__Address.Address;\n    amount: bigint;\n    sender: ox__Address.Address;\n    receiver: ox__Address.Address;\n    client: ThirdwebClient;\n    purchaseData?: unknown;\n    maxSteps?: number;\n  };\n\n  type Result = PreparedQuote & {\n    intent: {\n      originChainId: number;\n      originTokenAddress: ox__Address.Address;\n      destinationChainId: number;\n      destinationTokenAddress: ox__Address.Address;\n      amount: bigint;\n      purchaseData?: unknown;\n    };\n  };\n}\n", "import type { Hex as ox__Hex } from \"ox\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { UNIVERSAL_BRIDGE_URL } from \"./constants.js\";\nimport type { Status } from \"./types/Status.js\";\n\n/**\n * Retrieves a Universal Bridge quote for the provided sell intent. The quote will specify the expected `destinationAmount` that will be received in exchange for the specified `originAmount`, which is specified with the `sellAmountWei` option.\n *\n * The returned status will include both the origin and destination transactions and any finalized amounts for the route.\n *\n * @example\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * const status = await Bridge.status({\n *   transactionHash: \"0xe199ef82a0b6215221536e18ec512813c1aa10b4f5ed0d4dfdfcd703578da56d\",\n *   chainId: 8453,\n *   client: thirdwebClient,\n * });\n * ```\n *\n * If the transaction is complete, a response might look like:\n * ```typescript\n * {\n *   status: 'COMPLETED',\n *   originAmount: 200000000000000n,\n *   destinationAmount: 188625148000000n,\n *   originChainId: 8453,\n *   destinationChainId: 2741,\n *   originTokenAddress: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',\n *   destinationTokenAddress: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE',\n *   transactions: [\n *     {\n *       chainId: 8453,\n *       transactionHash: '0xe199ef82a0b6215221536e18ec512813c1aa10b4f5ed0d4dfdfcd703578da56d'\n *     },\n *     {\n *       chainId: 2741,\n *       transactionHash: '0xa70a82f42330f54be95a542e1fcfe6ed2dd9f07fb8c82ae67afb4342319f7433'\n *     }\n *   ],\n *   purchaseData: {\n *     foo: \"bar\"\n *   }\n * }\n * ```\n *\n * If the origin transaction hasn't been mined yet, a response might look like:\n * ```typescript\n * {\n *   status: \"NOT_FOUND\",\n * }\n * ```\n * This is to allow you to poll for the status without catching an error. Be sure your transaction hash and chain are correct though, as this could also represent a legitimate 404 if the transaction doesn't exist.\n *\n * If the transaction is still pending, a response might look like:\n * ```typescript\n * {\n *   status: \"PENDING\",\n *   originAmount: 1000000000000000000n,\n *   originChainId: 466,\n *   destinationChainId: 1,\n *   originTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *   destinationTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *   transactions: [\n *     {\n *       transactionHash: \"0xe199ef82a0b6215221536e18ec512813c1aa10b4f5ed0d4dfdfcd703578da56d\",\n *       chainId: 466,\n *     }\n *   ]\n * }\n * ```\n *\n * If the transaction failed, a response might look like:\n * ```typescript\n * {\n *   status: \"FAILED\",\n *   transactions: [\n *     {\n *       transactionHash: \"0xe199ef82a0b6215221536e18ec512813c1aa10b4f5ed0d4dfdfcd703578da56d\",\n *       chainId: 466,\n *     }\n *   ]\n * }\n * ```\n *\n * This status is for a **single origin transaction only**. If your route involves multiple transactions, you'll need to get the status for each of them individually.\n *\n * If sending multiple dependent sequential transactions, wait until `status` returns `COMPLETED` before sending the next transaction.\n *\n * You can access this function's input and output types with `status.Options` and `status.Result`, respectively.\n *\n * @param options - The options for the quote.\n * @param options.transactionHash - The hash of the origin transaction to get the bridge status for.\n * @param options.chainId - The chain ID of the origin token.\n * @param options.client - Your thirdweb client.\n *\n * @returns A promise that resolves to a status object for the transaction.\n *\n * @throws Will throw an error if there is an issue fetching the status.\n * @bridge\n * @beta\n */\nexport async function status(options: status.Options): Promise<status.Result> {\n  const { transactionHash, client } = options;\n  const chainId = \"chainId\" in options ? options.chainId : options.chain.id;\n\n  const clientFetch = getClientFetch(client);\n  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/status`);\n  url.searchParams.set(\"transactionHash\", transactionHash);\n  url.searchParams.set(\"chainId\", chainId.toString());\n\n  const response = await clientFetch(url.toString());\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new Error(\n      `${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`,\n    );\n  }\n\n  const { data }: { data: Status } = await response.json();\n  if (data.status === \"FAILED\") {\n    return {\n      status: \"FAILED\",\n      transactions: data.transactions,\n    };\n  }\n\n  if (data.status === \"PENDING\") {\n    return {\n      status: \"PENDING\",\n      originAmount: BigInt(data.originAmount),\n      originChainId: data.originChainId,\n      destinationChainId: data.destinationChainId,\n      originTokenAddress: data.originTokenAddress,\n      destinationTokenAddress: data.destinationTokenAddress,\n      transactions: data.transactions,\n    };\n  }\n\n  if (data.status === \"NOT_FOUND\") {\n    return {\n      status: \"NOT_FOUND\",\n      transactions: [],\n    };\n  }\n\n  return {\n    status: \"COMPLETED\",\n    originAmount: BigInt(data.originAmount),\n    destinationAmount: BigInt(data.destinationAmount),\n    originChainId: data.originChainId,\n    destinationChainId: data.destinationChainId,\n    originTokenAddress: data.originTokenAddress,\n    destinationTokenAddress: data.destinationTokenAddress,\n    transactions: data.transactions,\n    purchaseData: data.purchaseData,\n  };\n}\n\nexport declare namespace status {\n  type Options =\n    | {\n        transactionHash: ox__Hex.Hex;\n        chainId: number;\n        client: ThirdwebClient;\n      }\n    | {\n        transactionHash: ox__Hex.Hex;\n        chain: Chain;\n        client: ThirdwebClient;\n      };\n\n  type Result = Status;\n}\n", "import type { Address as ox__Address, Hex as ox__Hex } from \"ox\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { UNIVERSAL_BRIDGE_URL } from \"./constants.js\";\nimport type { Route } from \"./types/Route.js\";\n\n/**\n * Retrieves supported Universal Bridge routes based on the provided filters.\n *\n * When multiple filters are specified, a route must satisfy all filters to be included (it acts as an AND operator).\n *\n * @example\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * const routes = await Bridge.routes({\n *   client: thirdwebClient,\n * });\n * ```\n *\n * Returned routes might look something like:\n * ```typescript\n * [\n *    {\n *     destinationToken: {\n *       address: \"0x12c88a3C30A7AaBC1dd7f2c08a97145F5DCcD830\",\n *       chainId: 1,\n *       decimals: 18,\n *       iconUri: \"https://assets.coingecko.com/coins/images/37207/standard/G.jpg\",\n *       name: \"G7\",\n *       symbol: \"G7\",\n *     },\n *     originToken: {\n *       address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *       chainId: 480,\n *       decimals: 18,\n *       iconUri: \"https://assets.relay.link/icons/1/light.png\",\n *       name: \"Ether\",\n *       symbol: \"ETH\",\n *     }\n *   },\n *   {\n *     destinationToken: {\n *       address: \"0x4d224452801ACEd8B2F0aebE155379bb5D594381\",\n *       chainId: 1,\n *       decimals: 18,\n *       iconUri: \"https://coin-images.coingecko.com/coins/images/24383/large/apecoin.jpg?1696523566\",\n *       name: \"ApeCoin\",\n *       symbol: \"APE\",\n *     },\n *     originToken: {\n *       address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *       chainId: 480,\n *       decimals: 18,\n *       iconUri: \"https://assets.relay.link/icons/1/light.png\",\n *       name: \"Ether\",\n *       symbol: \"ETH\",\n *     }\n *   }\n * ]\n * ```\n *\n * You can filter for specific chains or tokens:\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * // Get all routes starting from mainnet ETH\n * const routes = await Bridge.routes({\n *   originChainId: 1,\n *   originTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *   client: thirdwebClient,\n * });\n * ```\n *\n * The returned routes will be limited based on the API. You can paginate through the results using the `limit` and `offset` parameters:\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * // Get the first 10 routes starting from mainnet ETH\n * const routes = await Bridge.routes({\n *   originChainId: 1,\n *   originTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *   limit: 10,\n *   offset: 0,\n *   client: thirdwebClient,\n * });\n * ```\n *\n * You can sort the returned routes by `popularity`:\n * ```ts\n * import { Bridge } from \"thirdweb\";\n *\n * // Get the 10 most popular routes starting from mainnet ETH\n * const routes = await Bridge.routes({\n *   originChainId: 1,\n *   originTokenAddress: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n *   limit: 10,\n *   offset: 0,\n *   sortBy: \"popularity\",\n *   client: thirdwebClient,\n * });\n * ```\n *\n * @param options - The options for the quote.\n * @param options.client - Your thirdweb client.\n * @param options.originChainId - Filter by a specific origin chain ID.\n * @param options.originTokenAddress - Filter by a specific origin token address.\n * @param options.destinationChainId - Filter by a specific destination chain ID.\n * @param options.destinationTokenAddress - Filter by a specific destination token address.\n * @param options.transactionHash - Filter by a specific transaction hash.\n * @param options.maxSteps - Limit the number of steps returned.\n * @param options.sortBy - Sort the routes by various categories.\n * @param options.limit - Limit the number of routes returned.\n * @param options.offset - Offset the number of routes returned.\n *\n * @returns A promise that resolves to an array of routes.\n *\n * @throws Will throw an error if there is an issue fetching the routes.\n * @bridge\n * @beta\n */\nexport async function routes(options: routes.Options): Promise<routes.Result> {\n  const {\n    client,\n    originChainId,\n    originTokenAddress,\n    destinationChainId,\n    destinationTokenAddress,\n    maxSteps,\n    sortBy,\n    limit,\n    offset,\n  } = options;\n\n  const clientFetch = getClientFetch(client);\n  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/routes`);\n  if (originChainId) {\n    url.searchParams.set(\"originChainId\", originChainId.toString());\n  }\n  if (originTokenAddress) {\n    url.searchParams.set(\"originTokenAddress\", originTokenAddress);\n  }\n  if (destinationChainId) {\n    url.searchParams.set(\"destinationChainId\", destinationChainId.toString());\n  }\n  if (destinationTokenAddress) {\n    url.searchParams.set(\"destinationTokenAddress\", destinationTokenAddress);\n  }\n  if (maxSteps) {\n    url.searchParams.set(\"maxSteps\", maxSteps.toString());\n  }\n  if (limit) {\n    url.searchParams.set(\"limit\", limit.toString());\n  }\n  if (offset) {\n    url.searchParams.set(\"offset\", offset.toString());\n  }\n  if (sortBy) {\n    url.searchParams.set(\"sortBy\", sortBy);\n  }\n\n  const response = await clientFetch(url.toString());\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new Error(`${errorJson.code} | ${errorJson.message}`);\n  }\n\n  const { data }: { data: Route[] } = await response.json();\n  return data;\n}\n\nexport declare namespace routes {\n  type Options = {\n    client: ThirdwebClient;\n    originChainId?: number;\n    originTokenAddress?: ox__Address.Address;\n    destinationChainId?: number;\n    destinationTokenAddress?: ox__Address.Address;\n    transactionHash?: ox__Hex.Hex;\n    sortBy?: \"popularity\";\n    maxSteps?: number;\n    limit?: number;\n    offset?: number;\n  };\n\n  type Result = Route[];\n}\n", "import type { ThirdwebClient } from \"../client/client.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { UNIVERSAL_BRIDGE_URL } from \"./constants.js\";\nimport type { Chain } from \"./types/Chain.js\";\n\n/**\n * Retrieves supported Universal Bridge chains.\n *\n * @example\n * ```typescript\n * import { Bridge } from \"thirdweb\";\n *\n * const chains = await Bridge.chains({\n *   client: thirdwebClient,\n * });\n * ```\n *\n * Returned chains might look something like:\n * ```typescript\n * [\n *   {\n *     chainId: 1,\n *     name: \"Ethereum\",\n *     icon: \"https://assets.thirdweb.com/chains/1.png\",\n *     nativeCurrency: {\n *       name: \"Ether\",\n *       symbol: \"ETH\",\n *       decimals: 18\n *     }\n *   },\n *   {\n *     chainId: 137,\n *     name: \"Polygon\",\n *     icon: \"https://assets.thirdweb.com/chains/137.png\",\n *     nativeCurrency: {\n *       name: \"MATIC\",\n *       symbol: \"MATIC\",\n *       decimals: 18\n *     }\n *   }\n * ]\n * ```\n *\n * @param options - The options for fetching chains.\n * @param options.client - Your thirdweb client.\n *\n * @returns A promise that resolves to an array of chains.\n *\n * @throws Will throw an error if there is an issue fetching the chains.\n * @bridge\n * @beta\n */\nexport async function chains(options: chains.Options): Promise<chains.Result> {\n  const { client } = options;\n\n  const clientFetch = getClientFetch(client);\n  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/chains`);\n\n  const response = await clientFetch(url.toString());\n  if (!response.ok) {\n    const errorJson = await response.json();\n    throw new Error(`${errorJson.code} | ${errorJson.message}`);\n  }\n\n  const { data }: { data: Chain[] } = await response.json();\n  return data;\n}\n\nexport declare namespace chains {\n  type Options = {\n    client: ThirdwebClient;\n  };\n\n  type Result = Chain[];\n}\n", "export {\n  serverWallet,\n  type ServerWalletOptions,\n  type ServerWallet,\n} from \"./server-wallet.js\";\nexport {\n  getTransactionStatus,\n  waitForTransactionHash,\n  type ExecutionResult,\n  type RevertData,\n} from \"./get-status.js\";\n", "// This file is auto-generated by @hey-api/openapi-ts\n\nimport {\n  type Config,\n  type ClientOptions as DefaultClientOptions,\n  createClient,\n  createConfig,\n} from \"@hey-api/client-fetch\";\nimport type { ClientOptions } from \"./types.gen.js\";\n\n/**\n * The `createClientConfig()` function will be called on client initialization\n * and the returned object will become the client's initial configuration.\n *\n * You may want to initialize your client this way instead of calling\n * `setConfig()`. This is useful for example if you're using Next.js\n * to ensure your client always has the correct values.\n */\nexport type CreateClientConfig<T extends DefaultClientOptions = ClientOptions> =\n  (\n    override?: Config<DefaultClientOptions & T>,\n  ) => Config<Required<DefaultClientOptions> & T>;\n\nexport const client = createClient(\n  createConfig<ClientOptions>({\n    baseUrl: \"http://localhost:3009\",\n  }),\n);\n", "// This file is auto-generated by @hey-api/openapi-ts\n\nimport type {\n  Client,\n  Options as ClientOptions,\n  TDataShape,\n} from \"@hey-api/client-fetch\";\nimport { client as _heyApiClient } from \"./client.gen.js\";\nimport type {\n  EncodeFunctionDataData,\n  EncodeFunctionDataResponse,\n  GetNativeBalanceData,\n  GetNativeBalanceResponse,\n  GetTransactionAnalyticsData,\n  GetTransactionAnalyticsResponse,\n  GetTransactionAnalyticsSummaryData,\n  GetTransactionAnalyticsSummaryResponse,\n  ReadContractData,\n  ReadContractResponse,\n  SearchTransactionsData,\n  SearchTransactionsResponse,\n  SendTransactionData,\n  SendTransactionResponse,\n  SignMessageData,\n  SignMessageResponse,\n  SignTransactionData,\n  SignTransactionResponse,\n  SignTypedDataData,\n  SignTypedDataResponse,\n  WriteContractData,\n  WriteContractResponse,\n} from \"./types.gen.js\";\n\nexport type Options<\n  TData extends TDataShape = TDataShape,\n  ThrowOnError extends boolean = boolean,\n> = ClientOptions<TData, ThrowOnError> & {\n  /**\n   * You can provide a client instance returned by `createClient()` instead of\n   * individual options. This might be also useful if you want to implement a\n   * custom client.\n   */\n  client?: Client;\n  /**\n   * You can pass arbitrary values through the `meta` object. This can be\n   * used to access values that aren't defined as part of the SDK function.\n   */\n  meta?: Record<string, unknown>;\n};\n\n/**\n * Write Contract\n * Call a write function on a contract.\n */\nexport const writeContract = <ThrowOnError extends boolean = false>(\n  options?: Options<WriteContractData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    WriteContractResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"x-secret-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/v1/write/contract\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n\n/**\n * Send Transaction\n * Send an encoded transaction or a batch of transactions\n */\nexport const sendTransaction = <ThrowOnError extends boolean = false>(\n  options?: Options<SendTransactionData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    SendTransactionResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"x-secret-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/v1/write/transaction\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n\n/**\n * Sign Transaction\n * Sign transactions without sending them.\n */\nexport const signTransaction = <ThrowOnError extends boolean = false>(\n  options?: Options<SignTransactionData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    SignTransactionResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"x-secret-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/v1/sign/transaction\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n\n/**\n * Sign Message\n * Sign arbitrary messages.\n */\nexport const signMessage = <ThrowOnError extends boolean = false>(\n  options?: Options<SignMessageData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    SignMessageResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"x-secret-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/v1/sign/message\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n\n/**\n * Sign Typed Data\n * Sign EIP-712 typed data.\n */\nexport const signTypedData = <ThrowOnError extends boolean = false>(\n  options?: Options<SignTypedDataData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    SignTypedDataResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"x-secret-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/v1/sign/typed-data\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n\n/**\n * Read Contract\n * Call read-only contract functions or batch read using multicall.\n */\nexport const readContract = <ThrowOnError extends boolean = false>(\n  options?: Options<ReadContractData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    ReadContractResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"x-secret-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/v1/read/contract\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n\n/**\n * Read Native Balance\n * Fetches the native cryptocurrency balance (e.g., ETH, MATIC) for a given address on a specific chain.\n */\nexport const getNativeBalance = <ThrowOnError extends boolean = false>(\n  options?: Options<GetNativeBalanceData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    GetNativeBalanceResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"x-secret-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/v1/read/balance\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n\n/**\n * Encode Function Data\n * Encode a contract call into transaction parameters (to, data, value).\n */\nexport const encodeFunctionData = <ThrowOnError extends boolean = false>(\n  options?: Options<EncodeFunctionDataData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    EncodeFunctionDataResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"x-secret-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/v1/encode/contract\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n\n/**\n * Search Transactions\n * Advanced search for transactions with complex nested filters\n */\nexport const searchTransactions = <ThrowOnError extends boolean = false>(\n  options?: Options<SearchTransactionsData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    SearchTransactionsResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"x-secret-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/v1/transactions/search\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n\n/**\n * Transaction Analytics\n * Get transaction count analytics over time with filtering\n */\nexport const getTransactionAnalytics = <ThrowOnError extends boolean = false>(\n  options?: Options<GetTransactionAnalyticsData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    GetTransactionAnalyticsResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"x-secret-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/v1/transactions/analytics\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n\n/**\n * Transaction Analytics Summary\n * Get a summary (total count and total gas calculation) for transactions within a time range, supporting complex nested filters.\n */\nexport const getTransactionAnalyticsSummary = <\n  ThrowOnError extends boolean = false,\n>(\n  options?: Options<GetTransactionAnalyticsSummaryData, ThrowOnError>,\n) => {\n  return (options?.client ?? _heyApiClient).post<\n    GetTransactionAnalyticsSummaryResponse,\n    unknown,\n    ThrowOnError\n  >({\n    security: [\n      {\n        name: \"x-secret-key\",\n        type: \"apiKey\",\n      },\n    ],\n    url: \"/v1/transactions/analytics-summary\",\n    ...options,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...options?.headers,\n    },\n  });\n};\n", "import { searchTransactions } from \"@thirdweb-dev/engine\";\nimport type { Chain } from \"../chains/types.js\";\nimport { getCachedChain } from \"../chains/utils.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport type { WaitForReceiptOptions } from \"../transaction/actions/wait-for-tx-receipt.js\";\nimport { getThirdwebBaseUrl } from \"../utils/domains.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { stringify } from \"../utils/json.js\";\nimport type { Prettify } from \"../utils/type-utils.js\";\n\nexport type RevertData = {\n  errorName: string;\n  errorArgs: Record<string, unknown>;\n};\n\ntype ExecutionResult4337Serialized =\n  | {\n      status: \"QUEUED\";\n    }\n  | {\n      status: \"FAILED\";\n      error: string;\n    }\n  | {\n      status: \"SUBMITTED\";\n      monitoringStatus: \"WILL_MONITOR\" | \"CANNOT_MONITOR\";\n      userOpHash: string;\n    }\n  | ({\n      status: \"CONFIRMED\";\n      userOpHash: Hex;\n      transactionHash: Hex;\n      actualGasCost: string;\n      actualGasUsed: string;\n      nonce: string;\n    } & (\n      | {\n          onchainStatus: \"SUCCESS\";\n        }\n      | {\n          onchainStatus: \"REVERTED\";\n          revertData?: RevertData;\n        }\n    ));\n\nexport type ExecutionResult = Prettify<\n  ExecutionResult4337Serialized & {\n    chain: Chain;\n    from: string | undefined;\n    id: string;\n  }\n>;\n\n/**\n * Get the execution status of a transaction.\n * @param args - The arguments for the transaction.\n * @param args.client - The thirdweb client to use.\n * @param args.transactionId - The id of the transaction to get the status of.\n * @engine\n * @example\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const executionResult = await Engine.getTransactionStatus({\n *   client,\n *   transactionId,\n * });\n * console.log(executionResult.status);\n * ```\n */\nexport async function getTransactionStatus(args: {\n  client: ThirdwebClient;\n  transactionId: string;\n}): Promise<ExecutionResult> {\n  const { client, transactionId } = args;\n  const searchResult = await searchTransactions({\n    baseUrl: getThirdwebBaseUrl(\"engineCloud\"),\n    fetch: getClientFetch(client),\n    body: {\n      filters: [\n        {\n          field: \"id\",\n          values: [transactionId],\n          operation: \"OR\",\n        },\n      ],\n    },\n  });\n\n  if (searchResult.error) {\n    throw new Error(\n      `Error searching for transaction ${transactionId}: ${stringify(\n        searchResult.error,\n      )}`,\n    );\n  }\n\n  const data = searchResult.data?.result?.transactions?.[0];\n\n  if (!data) {\n    throw new Error(`Transaction ${transactionId} not found`);\n  }\n\n  const executionResult = data.executionResult as ExecutionResult4337Serialized;\n  return {\n    ...executionResult,\n    chain: getCachedChain(Number(data.chainId)),\n    from: data.from ?? undefined,\n    id: data.id,\n  };\n}\n\n/**\n * Wait for a transaction to be submitted onchain and return the transaction hash.\n * @param args - The arguments for the transaction.\n * @param args.client - The thirdweb client to use.\n * @param args.transactionId - The id of the transaction to wait for.\n * @param args.timeoutInSeconds - The timeout in seconds.\n * @engine\n * @example\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const { transactionHash } = await Engine.waitForTransactionHash({\n *   client,\n *   transactionId, // the transaction id returned from enqueueTransaction\n * });\n * ```\n */\nexport async function waitForTransactionHash(args: {\n  client: ThirdwebClient;\n  transactionId: string;\n  timeoutInSeconds?: number;\n}): Promise<WaitForReceiptOptions> {\n  const startTime = Date.now();\n  const TIMEOUT_IN_MS = args.timeoutInSeconds\n    ? args.timeoutInSeconds * 1000\n    : 5 * 60 * 1000; // 5 minutes in milliseconds\n\n  while (Date.now() - startTime < TIMEOUT_IN_MS) {\n    const executionResult = await getTransactionStatus(args);\n    const status = executionResult.status;\n\n    switch (status) {\n      case \"FAILED\": {\n        throw new Error(\n          `Transaction failed: ${executionResult.error || \"Unknown error\"}`,\n        );\n      }\n      case \"CONFIRMED\": {\n        const onchainStatus =\n          executionResult && \"onchainStatus\" in executionResult\n            ? executionResult.onchainStatus\n            : null;\n        if (onchainStatus === \"REVERTED\") {\n          const revertData =\n            \"revertData\" in executionResult\n              ? executionResult.revertData\n              : undefined;\n          throw new Error(\n            `Transaction reverted: ${revertData?.errorName || \"\"} ${revertData?.errorArgs ? stringify(revertData.errorArgs) : \"\"}`,\n          );\n        }\n        return {\n          transactionHash: executionResult.transactionHash as Hex,\n          client: args.client,\n          chain: executionResult.chain,\n        };\n      }\n      default: {\n        // wait for the transaction to be confirmed\n        await new Promise((resolve) => setTimeout(resolve, 1000));\n      }\n    }\n  }\n  throw new Error(\n    `Transaction timed out after ${TIMEOUT_IN_MS / 1000} seconds`,\n  );\n}\n", "import {\n  type AaExecutionOptions,\n  type AaZksyncExecutionOptions,\n  sendTransaction,\n  signMessage,\n  signTypedData,\n} from \"@thirdweb-dev/engine\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { encode } from \"../transaction/actions/encode.js\";\nimport { toSerializableTransaction } from \"../transaction/actions/to-serializable-transaction.js\";\nimport type { PreparedTransaction } from \"../transaction/prepare-transaction.js\";\nimport { getThirdwebBaseUrl } from \"../utils/domains.js\";\nimport { type Hex, toHex } from \"../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../utils/fetch.js\";\nimport { stringify } from \"../utils/json.js\";\nimport { resolvePromisedValue } from \"../utils/promise/resolve-promised-value.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n} from \"../wallets/interfaces/wallet.js\";\nimport { waitForTransactionHash } from \"./get-status.js\";\n\n/**\n * Options for creating an server wallet.\n */\nexport type ServerWalletOptions = {\n  /**\n   * The thirdweb client to use for authentication to thirdweb services.\n   */\n  client: ThirdwebClient;\n  /**\n   * The vault access token to use your server wallet.\n   */\n  vaultAccessToken: string;\n  /**\n   * The server wallet address to use for sending transactions inside engine.\n   */\n  address: string;\n  /**\n   * The chain to use for signing messages and typed data (smart server wallet only).\n   */\n  chain?: Chain;\n  /**\n   * Optional custom execution options to use for sending transactions and signing data.\n   */\n  executionOptions?:\n    | Omit<AaExecutionOptions, \"chainId\">\n    | Omit<AaZksyncExecutionOptions, \"chainId\">;\n};\n\nexport type ServerWallet = Account & {\n  enqueueTransaction: (args: {\n    transaction: PreparedTransaction;\n    simulate?: boolean;\n  }) => Promise<{ transactionId: string }>;\n};\n\n/**\n * Create a server wallet for sending transactions and signing messages via engine (v3+).\n * @param options - The server wallet options.\n * @returns An account object that can be used to send transactions and sign messages.\n * @engine\n * @example\n * ### Creating a server wallet\n * ```ts\n * import { Engine } from \"thirdweb\";\n *\n * const client = createThirdwebClient({\n *   secretKey: \"<your-project-secret-key>\",\n * });\n *\n * const myServerWallet = Engine.serverWallet({\n *   client,\n *   address: \"<your-server-wallet-address>\",\n *   vaultAccessToken: \"<your-vault-access-token>\",\n * });\n * ```\n *\n * ### Sending a transaction\n * ```ts\n * // prepare the transaction\n * const transaction = claimTo({\n *   contract,\n *   to: \"0x...\",\n *   quantity: 1n,\n * });\n *\n * // enqueue the transaction\n * const { transactionId } = await myServerWallet.enqueueTransaction({\n *   transaction,\n * });\n * ```\n *\n * ### Polling for the transaction to be submitted onchain\n * ```ts\n * // optionally poll for the transaction to be submitted onchain\n * const { transactionHash } = await Engine.waitForTransactionHash({\n *   client,\n *   transactionId,\n * });\n * console.log(\"Transaction sent:\", transactionHash);\n * ```\n *\n * ### Getting the execution status of a transaction\n * ```ts\n * const executionResult = await Engine.getTransactionStatus({\n *   client,\n *   transactionId,\n * });\n * console.log(\"Transaction status:\", executionResult.status);\n * ```\n */\nexport function serverWallet(options: ServerWalletOptions): ServerWallet {\n  const { client, vaultAccessToken, address, chain, executionOptions } =\n    options;\n  const headers: HeadersInit = {\n    \"x-vault-access-token\": vaultAccessToken,\n  };\n\n  const getExecutionOptions = (chainId: number) => {\n    return executionOptions\n      ? {\n          ...executionOptions,\n          chainId: chainId.toString(),\n        }\n      : {\n          from: address,\n          chainId: chainId.toString(),\n        };\n  };\n\n  const enqueueTx = async (transaction: SendTransactionOption) => {\n    const body = {\n      executionOptions: getExecutionOptions(transaction.chainId),\n      params: [\n        {\n          to: transaction.to ?? undefined,\n          data: transaction.data,\n          value: transaction.value?.toString(),\n        },\n      ],\n    };\n\n    const result = await sendTransaction({\n      baseUrl: getThirdwebBaseUrl(\"engineCloud\"),\n      fetch: getClientFetch(client),\n      headers,\n      body,\n    });\n\n    if (result.error) {\n      throw new Error(`Error sending transaction: ${result.error}`);\n    }\n\n    const data = result.data?.result;\n    if (!data) {\n      throw new Error(\"No data returned from engine\");\n    }\n    const transactionId = data.transactions?.[0]?.id;\n    if (!transactionId) {\n      throw new Error(\"No transactionId returned from engine\");\n    }\n    return transactionId;\n  };\n\n  return {\n    address,\n    enqueueTransaction: async (args: {\n      transaction: PreparedTransaction;\n      simulate?: boolean;\n    }) => {\n      let serializedTransaction: SendTransactionOption;\n      if (args.simulate) {\n        serializedTransaction = await toSerializableTransaction({\n          transaction: args.transaction,\n        });\n      } else {\n        const [to, data, value] = await Promise.all([\n          args.transaction.to\n            ? resolvePromisedValue(args.transaction.to)\n            : null,\n          encode(args.transaction),\n          args.transaction.value\n            ? resolvePromisedValue(args.transaction.value)\n            : null,\n        ]);\n        serializedTransaction = {\n          chainId: args.transaction.chain.id,\n          data,\n          to: to ?? undefined,\n          value: value ?? undefined,\n        };\n      }\n      const transactionId = await enqueueTx(serializedTransaction);\n      return { transactionId };\n    },\n    sendTransaction: async (transaction: SendTransactionOption) => {\n      const transactionId = await enqueueTx(transaction);\n      return waitForTransactionHash({\n        client,\n        transactionId,\n      });\n    },\n    signMessage: async (data) => {\n      const { message, chainId } = data;\n      let engineMessage: string | Hex;\n      let isBytes = false;\n      if (typeof message === \"string\") {\n        engineMessage = message;\n      } else {\n        engineMessage = toHex(message.raw);\n        isBytes = true;\n      }\n\n      const signingChainId = chainId || chain?.id;\n      if (!signingChainId) {\n        throw new Error(\"Chain ID is required for signing messages\");\n      }\n\n      const signResult = await signMessage({\n        baseUrl: getThirdwebBaseUrl(\"engineCloud\"),\n        fetch: getClientFetch(client),\n        headers,\n        body: {\n          executionOptions: getExecutionOptions(signingChainId),\n          params: [\n            {\n              message: engineMessage,\n              messageFormat: isBytes ? \"hex\" : \"text\",\n            },\n          ],\n        },\n      });\n\n      if (signResult.error) {\n        throw new Error(\n          `Error signing message: ${stringify(signResult.error)}`,\n        );\n      }\n\n      const signatureResult = signResult.data?.result.results[0];\n      if (signatureResult?.success) {\n        return signatureResult.result.signature as Hex;\n      }\n\n      throw new Error(\n        `Failed to sign message: ${signatureResult?.error?.message || \"Unknown error\"}`,\n      );\n    },\n    signTypedData: async (typedData) => {\n      const signingChainId = chain?.id;\n      if (!signingChainId) {\n        throw new Error(\"Chain ID is required for signing messages\");\n      }\n\n      const signResult = await signTypedData({\n        baseUrl: getThirdwebBaseUrl(\"engineCloud\"),\n        fetch: getClientFetch(client),\n        headers,\n        body: {\n          executionOptions: getExecutionOptions(signingChainId),\n          // biome-ignore lint/suspicious/noExplicitAny: TODO: fix ts / hey-api type clash\n          params: [typedData as any],\n        },\n      });\n\n      if (signResult.error) {\n        throw new Error(\n          `Error signing message: ${stringify(signResult.error)}`,\n        );\n      }\n\n      const signatureResult = signResult.data?.result.results[0];\n      if (signatureResult?.success) {\n        return signatureResult.result.signature as Hex;\n      }\n\n      throw new Error(\n        `Failed to sign message: ${signatureResult?.error?.message || \"Unknown error\"}`,\n      );\n    },\n  };\n}\n", "import type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport type { OneOf, Prettify } from \"../../../../utils/type-utils.js\";\nimport type { Profile } from \"../authentication/types.js\";\nimport type { Ecosystem } from \"../wallet/types.js\";\n\nexport type GetUserResult = {\n  userId: string;\n  walletAddress: string;\n  smartAccountAddress?: string;\n  email?: string;\n  phone?: string;\n  createdAt: string;\n  profiles: Profile[];\n};\n\n/**\n * Gets user based on the provided query parameters.\n *  This function is only available on the server (a secret key is required in the client).\n *\n * @param options - The options for the get user function.\n * @param options.client - The Thirdweb client with a secret key included.\n * @param [options.walletAddress] - The wallet address generated by thirdweb to query by.\n * @param [options.email] - The email to query by.\n * @param [options.phone] - The phone number to query by.\n * @param [options.id] - The user ID to query by.\n * @param [options.externalWalletAddress] - The linked external wallet address to query by.\n *\n * @returns A user object or null if not found.\n *\n * @example\n * import { getUser } from \"thirdweb/wallets\";\n *\n * const user = await getUser({\n *   client,\n *   walletAddress: \"0x123...\",\n * });\n *\n * @wallet\n */\nexport async function getUser({\n  client,\n  walletAddress,\n  email,\n  phone,\n  id,\n  externalWalletAddress,\n  ecosystem,\n}: Prettify<\n  {\n    client: ThirdwebClient;\n    ecosystem?: Ecosystem;\n  } & OneOf<{\n    walletAddress?: string;\n    email?: string;\n    phone?: string;\n    id?: string;\n    externalWalletAddress?: string;\n  }>\n>): Promise<GetUserResult | null> {\n  if (!client.secretKey) {\n    throw new Error(\n      \"A secret key is required to query for users. If you're making this request from the server, please add a secret key to your client.\",\n    );\n  }\n\n  const url = new URL(\n    `${getThirdwebBaseUrl(\"inAppWallet\")}/api/2023-11-30/embedded-wallet/user-details`,\n  );\n\n  if (walletAddress) {\n    url.searchParams.set(\"queryBy\", \"walletAddress\");\n    url.searchParams.set(\"walletAddress\", walletAddress);\n  } else if (email) {\n    url.searchParams.set(\"queryBy\", \"email\");\n    url.searchParams.set(\"email\", email);\n  } else if (phone) {\n    url.searchParams.set(\"queryBy\", \"phone\");\n    url.searchParams.set(\"phone\", phone);\n  } else if (id) {\n    url.searchParams.set(\"queryBy\", \"id\");\n    url.searchParams.set(\"id\", id);\n  } else if (externalWalletAddress) {\n    url.searchParams.set(\"queryBy\", \"externalWalletAddress\");\n    url.searchParams.set(\"externalWalletAddress\", externalWalletAddress);\n  } else {\n    throw new Error(\n      \"Please provide a walletAddress, email, phone, id, or externalWalletAddress to query for users.\",\n    );\n  }\n\n  const clientFetch = getClientFetch(client, ecosystem);\n\n  const res = await clientFetch(url.toString());\n\n  if (!res.ok) {\n    const error = await res.text().catch(() => \"Unknown error\");\n    throw new Error(\n      `Failed to get profiles. ${res.status} ${res.statusText}: ${error}`,\n    );\n  }\n\n  const data = (await res.json()) as {\n    userId: string;\n    walletAddress: string;\n    smartAccountAddress?: string;\n    email?: string;\n    phone?: string;\n    createdAt: string;\n    linkedAccounts: Profile[];\n  }[];\n\n  return (\n    data.map((item) => ({\n      userId: item.userId,\n      walletAddress: item.walletAddress,\n      smartAccountAddress: item.smartAccountAddress,\n      email: item.email,\n      phone: item.phone,\n      createdAt: item.createdAt,\n      profiles: item.linkedAccounts.map((profile) => {\n        return {\n          type: (profile.type as string) === \"siwe\" ? \"wallet\" : profile.type,\n          details: profile.details,\n        };\n      }),\n    }))[0] || null\n  );\n}\n", "import type { Abi, AbiFunction } from \"abitype\";\nimport { parseAbiItem } from \"abitype\";\nimport { resolveContractAbi } from \"../contract/actions/resolve-abi.js\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\n\n/**\n * Resolves and returns the ABI function with the specified method name.\n * Throws an error if the function is not found in the ABI.\n * @template abiFn - The type of the ABI function.\n * @param method - The name of the method to resolve.\n * @returns The resolved ABI function.\n * @throws Error if the function is not found in the ABI.\n * @example\n * ```ts\n * import { resolveMethod, prepareContractCall } from \"thirdweb\";\n * const tx = prepareContractCall({\n *  contract,\n *  // automatically resolves the necessary abi to encode the transaction\n *  method: resolveMethod(\"transfer\"),\n *  // however there is no type completion for params in this case (as the resolution is async and happens at runtime)\n *  params: [to, value],\n * });\n * ```\n * @contract\n */\nexport function resolveMethod<\n  abiFn extends AbiFunction,\n  TAbi extends Abi = Abi,\n>(method: string) {\n  return async (contract: ThirdwebContract<TAbi>) => {\n    if (typeof method === \"string\" && method.startsWith(\"function \")) {\n      // we know it will be an abi function so we can cast it\n      return parseAbiItem(method) as AbiFunction;\n    }\n\n    const resolvedAbi = contract.abi?.length\n      ? contract.abi\n      : await resolveContractAbi<Abi>(contract);\n    // we try to find the abiFunction in the abi\n    const abiFunction = resolvedAbi.find((item) => {\n      // if the item is not a function we can ignore it\n      if (item.type !== \"function\") {\n        return false;\n      }\n      // if the item is a function we can compare the name\n      return item.name === method;\n    }) as abiFn | undefined;\n\n    if (!abiFunction) {\n      throw new Error(`could not find function with name \"${method}\" in abi`);\n    }\n    return abiFunction;\n  };\n}\n", "export let extraEntropy = false\n\n/** @internal */\nexport function setExtraEntropy(entropy: boolean) {\n  extraEntropy = entropy\n}\n", "import { secp256k1 } from '@noble/curves/secp256k1'\nimport * as Address from './Address.js'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\nimport * as Entropy from './internal/entropy.js'\nimport type { OneOf } from './internal/types.js'\n\n/** Re-export of noble/curves secp256k1 utilities. */\nexport const noble = secp256k1\n\n/**\n * Computes the secp256k1 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const publicKey = Secp256k1.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey(\n  options: getPublicKey.Options,\n): PublicKey.PublicKey {\n  const { privateKey } = options\n  const point = secp256k1.ProjectivePoint.fromPrivateKey(\n    Hex.from(privateKey).slice(2),\n  )\n  return PublicKey.from(point)\n}\n\nexport declare namespace getPublicKey {\n  type Options = {\n    /**\n     * Private key to compute the public key from.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType =\n    | Hex.from.ErrorType\n    | PublicKey.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random ECDSA private key on the secp256k1 curve.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: randomPrivateKey.Options<as> = {},\n): randomPrivateKey.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const bytes = secp256k1.utils.randomPrivateKey()\n  if (as === 'Hex') return Hex.fromBytes(bytes) as never\n  return bytes as never\n}\n\nexport declare namespace randomPrivateKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Recovers the signing address from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const address = Secp256k1.recoverAddress({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered address.\n */\nexport function recoverAddress(\n  options: recoverAddress.Options,\n): recoverAddress.ReturnType {\n  return Address.fromPublicKey(recoverPublicKey(options))\n}\n\nexport declare namespace recoverAddress {\n  type Options = {\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Signature of the payload. */\n    signature: Signature.Signature\n  }\n\n  type ReturnType = Address.Address\n\n  type ErrorType =\n    | Address.fromPublicKey.ErrorType\n    | recoverPublicKey.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = Secp256k1.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nexport function recoverPublicKey(\n  options: recoverPublicKey.Options,\n): PublicKey.PublicKey {\n  const { payload, signature } = options\n  const { r, s, yParity } = signature\n  const signature_ = new secp256k1.Signature(\n    BigInt(r),\n    BigInt(s),\n  ).addRecoveryBit(yParity)\n  const point = signature_.recoverPublicKey(Hex.from(payload).substring(2))\n  return PublicKey.from(point)\n}\n\nexport declare namespace recoverPublicKey {\n  type Options = {\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Signature of the payload. */\n    signature: Signature.Signature\n  }\n\n  type ErrorType =\n    | PublicKey.from.ErrorType\n    | Hex.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs the payload with the provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nexport function sign(options: sign.Options): Signature.Signature {\n  const {\n    extraEntropy = Entropy.extraEntropy,\n    hash,\n    payload,\n    privateKey,\n  } = options\n  const { r, s, recovery } = secp256k1.sign(\n    Bytes.from(payload),\n    Bytes.from(privateKey),\n    {\n      extraEntropy:\n        typeof extraEntropy === 'boolean'\n          ? extraEntropy\n          : Hex.from(extraEntropy).slice(2),\n      lowS: true,\n      ...(hash ? { prehash: true } : {}),\n    },\n  )\n  return {\n    r,\n    s,\n    yParity: recovery,\n  }\n}\n\nexport declare namespace sign {\n  type Options = {\n    /**\n     * Extra entropy to add to the signing process. Setting to `false` will disable it.\n     * @default true\n     */\n    extraEntropy?: boolean | Hex.Hex | Bytes.Bytes | undefined\n    /**\n     *  If set to `true`, the payload will be hashed (sha256) before being signed.\n     */\n    hash?: boolean | undefined\n    /**\n     * Payload to sign.\n     */\n    payload: Hex.Hex | Bytes.Bytes\n    /**\n     * ECDSA private key.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Bytes.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided address.\n *\n * @example\n * ### Verify with Ethereum Address\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Verify with Public Key\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = '0x...'\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided address.\n */\nexport function verify(options: verify.Options): boolean {\n  const { address, hash, payload, publicKey, signature } = options\n  if (address)\n    return Address.isEqual(address, recoverAddress({ payload, signature }))\n  return secp256k1.verify(\n    signature,\n    Bytes.from(payload),\n    PublicKey.toBytes(publicKey),\n    ...(hash ? [{ prehash: true, lowS: true }] : []),\n  )\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** If set to `true`, the payload will be hashed (sha256) before being verified. */\n    hash?: boolean | undefined\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n  } & OneOf<\n    | {\n        /** Address that signed the payload. */\n        address: Address.Address\n        /** Signature of the payload. */\n        signature: Signature.Signature\n      }\n    | {\n        /** Public key that signed the payload. */\n        publicKey: PublicKey.PublicKey<boolean>\n        /** Signature of the payload. */\n        signature: Signature.Signature<false>\n      }\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n", "import * as ox__Hash from \"ox/Hash\";\nimport * as ox__Secp256k1 from \"ox/Secp256k1\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport {\n  type SerializableTransaction,\n  serializeTransaction,\n} from \"../serialize-transaction.js\";\n\nexport type SignTransactionOptions = {\n  transaction: SerializableTransaction;\n  privateKey: Hex;\n  // TODO: Add optional custom serializer here\n};\n\n/**\n * Signs a transaction to be sent to a node.\n * @param options The options for signing.\n * @param options.transaction - The transaction object to sign\n * @param options.privateKey - The account private key\n * @returns The signed transaction as a hex string\n * @example\n * ```ts\n * import { signTransaction } from \"thirdweb\";\n * signTransaction({\n *   transaction: {\n *     ...\n *   },\n *   privateKey: \"0x...\",\n * });\n * ```\n * @transaction\n */\nexport function signTransaction({\n  transaction,\n  privateKey,\n}: SignTransactionOptions): Hex {\n  const serializedTransaction = serializeTransaction({ transaction });\n\n  const signature = ox__Secp256k1.sign({\n    payload: ox__Hash.keccak256(serializedTransaction),\n    privateKey: privateKey,\n  });\n  return serializeTransaction({\n    transaction: { ...transaction, ...signature },\n  });\n}\n", "import type * as ox__Signature from \"ox/Signature\";\nimport * as ox__TypedData from \"ox/TypedData\";\nimport type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport type { Hex } from \"../utils/encoding/hex.js\";\nimport type { HashTypedDataParams } from \"../utils/hashing/hashTypedData.js\";\nimport { type VerifyHashParams, verifyHash } from \"./verify-hash.js\";\n\nexport type VerifyTypedDataParams<\n  typedData extends\n    | ox__TypedData.TypedData\n    | Record<string, unknown> = ox__TypedData.TypedData,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n> = Omit<VerifyHashParams, \"hash\"> &\n  ox__TypedData.Definition<typedData, primaryType> & {\n    address: string;\n    signature: string | Uint8Array | ox__Signature.Signature;\n    client: ThirdwebClient;\n    chain: Chain;\n    accountFactory?: {\n      address: string;\n      verificationCalldata: Hex;\n    };\n  };\n\n/**\n * Verify am [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data signature. This function is interoperable with all wallet types (smart accounts or EOAs).\n *\n * @param {string} options.address The address that signed the typed data\n * @param {string | Uint8Array | Signature} options.signature The signature that was signed\n * @param {ThirdwebClient} options.client The Thirdweb client\n * @param {Chain} options.chain The chain that the address is on. For an EOA, this can be any chain.\n * @param {string} [options.accountFactory.address] The address of the account factory that created the account if using a smart account with a custom account factory\n * @param {Hex} [options.accountFactory.verificationCalldata] The calldata that was used to create the account if using a smart account with a custom account factory\n * @param {typeof VerifyTypedDataParams.message} options.message The EIP-712 message that was signed.\n * @param {typeof VerifyTypedDataParams.domain} options.domain The EIP-712 domain that was signed.\n * @param {typeof VerifyTypedDataParams.primaryType} options.primaryType The EIP-712 primary type that was signed.\n * @param {typeof VerifyTypedDataParams.types} options.types The EIP-712 types that were signed.\n *\n * @returns {Promise<boolean>} A promise that resolves to `true` if the signature is valid, or `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifyTypedData } from \"thirdweb/utils\";\n * const isValid = await verifyTypedData({\n *   address: \"0x...\",\n *   signature: \"0x...\",\n *   client,\n *   chain,\n *   domain: {\n      name: \"Ether Mail\",\n      version: \"1\",\n      chainId: 1,\n      verifyingContract: \"0x0000000000000000000000000000000000000000\",\n    },\n *   primaryType: \"Mail\",\n *   types: {\n      Person: [\n        { name: \"name\", type: \"string\" },\n        { name: \"wallet\", type: \"address\" },\n      ],\n      Mail: [\n        { name: \"from\", type: \"Person\" },\n        { name: \"to\", type: \"Person\" },\n        { name: \"contents\", type: \"string\" },\n      ],\n    },\n    message: {\n      from: {\n        name: \"Cow\",\n        wallet: \"0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826\",\n      },\n      to: {\n        name: \"Bob\",\n        wallet: \"0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB\",\n      },\n      contents: \"Hello, Bob!\",\n    },\n * });\n * ```\n *\n * @auth\n */\nexport async function verifyTypedData<\n  typedData extends ox__TypedData.TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\",\n>({\n  address,\n  signature,\n  client,\n  chain,\n  accountFactory,\n  message,\n  domain,\n  primaryType,\n  types,\n}: VerifyTypedDataParams<typedData, primaryType>): Promise<boolean> {\n  const messageHash = ox__TypedData.getSignPayload({\n    message,\n    domain,\n    primaryType,\n    types,\n  } as HashTypedDataParams);\n  return verifyHash({\n    hash: messageHash,\n    signature,\n    address,\n    chain,\n    client,\n    accountFactory,\n  });\n}\n", "import type * as ox__Authorization from \"ox/Authorization\";\nimport type { Address } from \"../../../utils/address.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\n\n/**\n * An EIP-7702 authorization object fully prepared and ready for signing.\n *\n * @beta\n * @transaction\n */\nexport type AuthorizationRequest = {\n  address: Address;\n  chainId: number;\n  nonce: bigint;\n};\n\n/**\n * Represents a signed EIP-7702 authorization object.\n *\n * @beta\n * @transaction\n */\nexport type SignedAuthorization = ox__Authorization.ListSigned[number];\n\n/**\n * Sign the given EIP-7702 authorization object.\n * @param options - The options for `signAuthorization`\n * Refer to the type [`SignAuthorizationOptions`](https://portal.thirdweb.com/references/typescript/v5/SignAuthorizationOptions)\n * @returns The signed authorization object\n *\n * ```ts\n * import { signAuthorization } from \"thirdweb\";\n *\n * const authorization = await signAuthorization({\n *     request: {\n *         address: \"0x...\",\n *         chainId: 911867,\n *         nonce: 100n,\n *     },\n *     account: myAccount,\n * });\n * ```\n *\n * @beta\n * @transaction\n */\nexport async function signAuthorization(options: {\n  account: Account;\n  request: AuthorizationRequest;\n}): Promise<SignedAuthorization> {\n  const { account, request } = options;\n  if (typeof account.signAuthorization === \"undefined\") {\n    throw new Error(\n      \"This account type does not yet support signing EIP-7702 authorizations\",\n    );\n  }\n  return account.signAuthorization(request);\n}\n"],
  "mappings": "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",
  "names": ["sha256", "sha256", "client", "prepare", "quote", "quote", "client", "prepare", "client", "client", "client", "sendTransaction", "client", "status", "client", "sendTransaction", "client", "extraEntropy", "from", "client"]
}
