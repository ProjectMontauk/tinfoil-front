import {
  bytesToBigInt,
  bytesToBool,
  bytesToNumber,
  bytesToString,
  deploySmartAccount,
  fromBytes,
  verifyHash
} from "./chunk-PETDUVCB.js";
import {
  J,
  w
} from "./chunk-X2AGAVBN.js";
import {
  eth_estimateGas
} from "./chunk-2LFISE3E.js";
import {
  eth_getTransactionCount
} from "./chunk-WELVAK7E.js";
import {
  serializeTransaction
} from "./chunk-PUXE2NVY.js";
import "./chunk-LZKMOSPQ.js";
import {
  eth_getStorageAt
} from "./chunk-J6Z62PW4.js";
import {
  eth_getLogs,
  getBuyWithCryptoHistory,
  getContractEvents,
  isBaseTransactionOptions,
  simulateTransaction,
  watchContractEvents
} from "./chunk-R7RUNJCH.js";
import {
  getBuyWithCryptoQuote,
  getBuyWithCryptoStatus,
  getBuyWithCryptoTransfer
} from "./chunk-URZDXLR3.js";
import {
  sendAndConfirmTransaction,
  sendBatchTransaction
} from "./chunk-EEW47C67.js";
import {
  eth_getBalance
} from "./chunk-IP5PDB6V.js";
import {
  insight_exports
} from "./chunk-LGNYDVMM.js";
import "./chunk-I535C34Q.js";
import {
  parseEventLogs,
  prepareEvent
} from "./chunk-N2GC2KFE.js";
import {
  sendTransaction
} from "./chunk-ZDRPKWVC.js";
import "./chunk-PA7ZDDNX.js";
import {
  prepareContractCall
} from "./chunk-GN5VQLP7.js";
import "./chunk-SHMPOGED.js";
import "./chunk-OCUM3LYH.js";
import {
  NATIVE_TOKEN_ADDRESS,
  ZERO_ADDRESS
} from "./chunk-YCZ3YGMG.js";
import {
  eth_blockNumber,
  eth_getTransactionReceipt,
  waitForReceipt,
  watchBlockNumber
} from "./chunk-IV7TI4DW.js";
import "./chunk-QWTK625L.js";
import "./chunk-RBDMC2I3.js";
import "./chunk-ZPS4DW3R.js";
import "./chunk-47CFHYO7.js";
import {
  eth_sendRawTransaction
} from "./chunk-CMXLKATA.js";
import {
  concatHex
} from "./chunk-SX7HLH7J.js";
import {
  toSerializableTransaction
} from "./chunk-IKNCNHEM.js";
import "./chunk-PACFWEKZ.js";
import {
  encode
} from "./chunk-H7PSGVWH.js";
import {
  prepareTransaction
} from "./chunk-QGXAPRFG.js";
import "./chunk-WWY7S4YD.js";
import {
  eth_getCode
} from "./chunk-TZGUFJTV.js";
import {
  eth_call,
  readContract
} from "./chunk-3JQSFVWL.js";
import {
  estimateGasCost
} from "./chunk-E4LYAXWZ.js";
import {
  estimateGas,
  eth_gasPrice,
  eth_getBlockByNumber,
  eth_maxPriorityFeePerGas,
  getGasPrice,
  resolveContractAbi,
  resolvePromisedValue
} from "./chunk-NOV7XZ3Z.js";
import {
  fromGwei,
  toEther,
  toTokens,
  toUnits,
  toWei
} from "./chunk-HAADYJEF.js";
import "./chunk-6IIMS5BN.js";
import "./chunk-S6KQNYT6.js";
import "./chunk-FP4BM2OU.js";
import {
  getSignPayload
} from "./chunk-H25PTKOP.js";
import {
  keccak256
} from "./chunk-IIYHAAZ7.js";
import "./chunk-V4DR3IRU.js";
import {
  getRpcClient
} from "./chunk-4QK53XYS.js";
import {
  getContract
} from "./chunk-6UGMW7YR.js";
import {
  getAddress,
  isAddress,
  keccak256 as keccak2562
} from "./chunk-ML3AFUII.js";
import {
  boolToBytes,
  hexToBytes,
  numberToBytes,
  stringToBytes,
  toBytes
} from "./chunk-XHJTXGWB.js";
import {
  boolToHex,
  fromHex,
  hexToBigInt,
  hexToBool,
  hexToNumber,
  hexToString,
  hexToUint8Array,
  isHex,
  numberToHex,
  padHex,
  stringToHex,
  toHex,
  uint8ArrayToHex
} from "./chunk-OISUMZDD.js";
import {
  from,
  from2
} from "./chunk-WS4IU3RU.js";
import {
  formatBlock,
  formatTransaction
} from "./chunk-CSXIMWT5.js";
import "./chunk-NZNWWTAY.js";
import {
  secp256k1
} from "./chunk-YQVK3R6M.js";
import {
  sha256
} from "./chunk-YI5GCKPB.js";
import "./chunk-AZC75Q4J.js";
import "./chunk-VWCCEMFN.js";
import {
  parseAbiItem
} from "./chunk-HXWRQBIO.js";
import "./chunk-XM2SSLRL.js";
import "./chunk-4XTXPSIE.js";
import "./chunk-URITLAIO.js";
import {
  stringify
} from "./chunk-2CIJO3V3.js";
import {
  defineChain,
  getCachedChain
} from "./chunk-LTI5ICKI.js";
import "./chunk-MTFDOOBS.js";
import {
  getClientFetch,
  isJWT
} from "./chunk-6FJDHQ5V.js";
import "./chunk-3OXDSLPJ.js";
import {
  LruMap
} from "./chunk-PPP72TBL.js";
import {
  getThirdwebBaseUrl
} from "./chunk-4ACTGFHH.js";
import {
  __export
} from "./chunk-OS7ZSSJM.js";

// node_modules/thirdweb/dist/esm/utils/hashing/sha256.js
function sha2562(value, to) {
  const bytes = sha256(isHex(value, { strict: false }) ? hexToUint8Array(value) : value);
  if (to === "bytes") {
    return bytes;
  }
  return uint8ArrayToHex(bytes);
}

// node_modules/thirdweb/dist/esm/utils/client-id.js
var cache = new LruMap(4096);
function computeClientIdFromSecretKey(secretKey) {
  if (cache.has(secretKey)) {
    return cache.get(secretKey);
  }
  const cId = sha2562(stringToBytes(secretKey)).slice(2, 34);
  cache.set(secretKey, cId);
  return cId;
}

// node_modules/thirdweb/dist/esm/client/client.js
function createThirdwebClient(options) {
  const { clientId, secretKey, ...rest } = options;
  let realClientId = clientId;
  if (secretKey) {
    if (isJWT(secretKey)) {
      if (!clientId) {
        throw new Error("clientId must be provided when using a JWT secretKey");
      }
    } else {
      realClientId = clientId ?? computeClientIdFromSecretKey(secretKey);
    }
  }
  if (!realClientId) {
    throw new Error("clientId or secretKey must be provided");
  }
  return {
    ...rest,
    clientId: realClientId,
    secretKey
  };
}

// node_modules/thirdweb/dist/esm/rpc/actions/eth_getBlockByHash.js
async function eth_getBlockByHash(request, params) {
  const includeTransactions = params.includeTransactions ?? false;
  const block = await request({
    method: "eth_getBlockByHash",
    params: [params.blockHash, includeTransactions]
  });
  if (!block) {
    throw new Error("Block not found");
  }
  return formatBlock(block);
}

// node_modules/thirdweb/dist/esm/rpc/actions/eth_getTransactionByHash.js
async function eth_getTransactionByHash(request, params) {
  const receipt = await request({
    method: "eth_getTransactionByHash",
    params: [params.hash]
  });
  if (!receipt) {
    throw new Error("Transaction not found.");
  }
  return formatTransaction(receipt);
}

// node_modules/thirdweb/dist/esm/bridge/index.js
var bridge_exports = {};
__export(bridge_exports, {
  Buy: () => Buy_exports,
  Sell: () => Sell_exports,
  chains: () => chains,
  routes: () => routes,
  status: () => status
});

// node_modules/thirdweb/dist/esm/bridge/Buy.js
var Buy_exports = {};
__export(Buy_exports, {
  prepare: () => prepare,
  quote: () => quote
});

// node_modules/thirdweb/dist/esm/bridge/constants.js
var UNIVERSAL_BRIDGE_URL = "https://bridge.thirdweb.com/v1";

// node_modules/thirdweb/dist/esm/bridge/Buy.js
async function quote(options) {
  const { originChainId, originTokenAddress, destinationChainId, destinationTokenAddress, client: client2, maxSteps } = options;
  const amount = "buyAmountWei" in options ? options.buyAmountWei : options.amount;
  const clientFetch = getClientFetch(client2);
  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/buy/quote`);
  url.searchParams.set("originChainId", originChainId.toString());
  url.searchParams.set("originTokenAddress", originTokenAddress);
  url.searchParams.set("destinationChainId", destinationChainId.toString());
  url.searchParams.set("destinationTokenAddress", destinationTokenAddress);
  url.searchParams.set("buyAmountWei", amount.toString());
  if (maxSteps) {
    url.searchParams.set("maxSteps", maxSteps.toString());
  }
  const response = await clientFetch(url.toString());
  if (!response.ok) {
    const errorJson = await response.json();
    throw new Error(`${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`);
  }
  const { data } = await response.json();
  return {
    originAmount: BigInt(data.originAmount),
    destinationAmount: BigInt(data.destinationAmount),
    blockNumber: data.blockNumber ? BigInt(data.blockNumber) : void 0,
    timestamp: data.timestamp,
    estimatedExecutionTimeMs: data.estimatedExecutionTimeMs,
    steps: data.steps,
    intent: {
      originChainId,
      originTokenAddress,
      destinationChainId,
      destinationTokenAddress,
      buyAmountWei: amount,
      amount
    }
  };
}
async function prepare(options) {
  const { originChainId, originTokenAddress, destinationChainId, destinationTokenAddress, sender, receiver, client: client2, amount, purchaseData, maxSteps } = options;
  const clientFetch = getClientFetch(client2);
  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/buy/prepare`);
  const response = await clientFetch(url.toString(), {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: stringify({
      buyAmountWei: amount.toString(),
      originChainId: originChainId.toString(),
      originTokenAddress,
      destinationChainId: destinationChainId.toString(),
      destinationTokenAddress,
      sender,
      receiver,
      purchaseData,
      maxSteps
    })
  });
  if (!response.ok) {
    const errorJson = await response.json();
    throw new Error(`${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`);
  }
  const { data } = await response.json();
  return {
    originAmount: BigInt(data.originAmount),
    destinationAmount: BigInt(data.destinationAmount),
    blockNumber: data.blockNumber ? BigInt(data.blockNumber) : void 0,
    timestamp: data.timestamp,
    estimatedExecutionTimeMs: data.estimatedExecutionTimeMs,
    steps: data.steps.map((step) => ({
      ...step,
      transactions: step.transactions.map((transaction) => ({
        ...transaction,
        value: transaction.value ? BigInt(transaction.value) : void 0,
        client: client2,
        chain: defineChain(transaction.chainId)
      }))
    })),
    intent: {
      originChainId,
      originTokenAddress,
      destinationChainId,
      destinationTokenAddress,
      amount
    }
  };
}

// node_modules/thirdweb/dist/esm/bridge/Sell.js
var Sell_exports = {};
__export(Sell_exports, {
  prepare: () => prepare2,
  quote: () => quote2
});
async function quote2(options) {
  const { originChainId, originTokenAddress, destinationChainId, destinationTokenAddress, amount, client: client2, maxSteps } = options;
  const clientFetch = getClientFetch(client2);
  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/sell/quote`);
  url.searchParams.set("originChainId", originChainId.toString());
  url.searchParams.set("originTokenAddress", originTokenAddress);
  url.searchParams.set("destinationChainId", destinationChainId.toString());
  url.searchParams.set("destinationTokenAddress", destinationTokenAddress);
  url.searchParams.set("sellAmountWei", amount.toString());
  if (typeof maxSteps !== "undefined") {
    url.searchParams.set("maxSteps", maxSteps.toString());
  }
  const response = await clientFetch(url.toString());
  if (!response.ok) {
    const errorJson = await response.json();
    throw new Error(`${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`);
  }
  const { data } = await response.json();
  return {
    originAmount: BigInt(data.originAmount),
    destinationAmount: BigInt(data.destinationAmount),
    blockNumber: data.blockNumber ? BigInt(data.blockNumber) : void 0,
    timestamp: data.timestamp,
    estimatedExecutionTimeMs: data.estimatedExecutionTimeMs,
    steps: data.steps,
    intent: {
      originChainId,
      originTokenAddress,
      destinationChainId,
      destinationTokenAddress,
      amount
    }
  };
}
async function prepare2(options) {
  const { originChainId, originTokenAddress, destinationChainId, destinationTokenAddress, amount, sender, receiver, client: client2, purchaseData, maxSteps } = options;
  const clientFetch = getClientFetch(client2);
  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/sell/prepare`);
  const response = await clientFetch(url.toString(), {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: stringify({
      sellAmountWei: amount.toString(),
      originChainId: originChainId.toString(),
      originTokenAddress,
      destinationChainId: destinationChainId.toString(),
      destinationTokenAddress,
      sender,
      receiver,
      purchaseData,
      maxSteps
    })
  });
  if (!response.ok) {
    const errorJson = await response.json();
    throw new Error(`${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`);
  }
  const { data } = await response.json();
  return {
    originAmount: BigInt(data.originAmount),
    destinationAmount: BigInt(data.destinationAmount),
    blockNumber: data.blockNumber ? BigInt(data.blockNumber) : void 0,
    timestamp: data.timestamp,
    estimatedExecutionTimeMs: data.estimatedExecutionTimeMs,
    steps: data.steps.map((step) => ({
      ...step,
      transactions: step.transactions.map((transaction) => ({
        ...transaction,
        value: transaction.value ? BigInt(transaction.value) : void 0,
        client: client2,
        chain: defineChain(transaction.chainId)
      }))
    })),
    expiration: data.expiration,
    intent: {
      originChainId,
      originTokenAddress,
      destinationChainId,
      destinationTokenAddress,
      amount,
      purchaseData
    }
  };
}

// node_modules/thirdweb/dist/esm/bridge/Status.js
async function status(options) {
  const { transactionHash, client: client2 } = options;
  const chainId = "chainId" in options ? options.chainId : options.chain.id;
  const clientFetch = getClientFetch(client2);
  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/status`);
  url.searchParams.set("transactionHash", transactionHash);
  url.searchParams.set("chainId", chainId.toString());
  const response = await clientFetch(url.toString());
  if (!response.ok) {
    const errorJson = await response.json();
    throw new Error(`${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`);
  }
  const { data } = await response.json();
  if (data.status === "FAILED") {
    return {
      status: "FAILED",
      transactions: data.transactions
    };
  }
  if (data.status === "PENDING") {
    return {
      status: "PENDING",
      originAmount: BigInt(data.originAmount),
      originChainId: data.originChainId,
      destinationChainId: data.destinationChainId,
      originTokenAddress: data.originTokenAddress,
      destinationTokenAddress: data.destinationTokenAddress,
      transactions: data.transactions
    };
  }
  if (data.status === "NOT_FOUND") {
    return {
      status: "NOT_FOUND",
      transactions: []
    };
  }
  return {
    status: "COMPLETED",
    originAmount: BigInt(data.originAmount),
    destinationAmount: BigInt(data.destinationAmount),
    originChainId: data.originChainId,
    destinationChainId: data.destinationChainId,
    originTokenAddress: data.originTokenAddress,
    destinationTokenAddress: data.destinationTokenAddress,
    transactions: data.transactions,
    purchaseData: data.purchaseData
  };
}

// node_modules/thirdweb/dist/esm/bridge/Routes.js
async function routes(options) {
  const { client: client2, originChainId, originTokenAddress, destinationChainId, destinationTokenAddress, maxSteps, sortBy, limit, offset } = options;
  const clientFetch = getClientFetch(client2);
  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/routes`);
  if (originChainId) {
    url.searchParams.set("originChainId", originChainId.toString());
  }
  if (originTokenAddress) {
    url.searchParams.set("originTokenAddress", originTokenAddress);
  }
  if (destinationChainId) {
    url.searchParams.set("destinationChainId", destinationChainId.toString());
  }
  if (destinationTokenAddress) {
    url.searchParams.set("destinationTokenAddress", destinationTokenAddress);
  }
  if (maxSteps) {
    url.searchParams.set("maxSteps", maxSteps.toString());
  }
  if (limit) {
    url.searchParams.set("limit", limit.toString());
  }
  if (offset) {
    url.searchParams.set("offset", offset.toString());
  }
  if (sortBy) {
    url.searchParams.set("sortBy", sortBy);
  }
  const response = await clientFetch(url.toString());
  if (!response.ok) {
    const errorJson = await response.json();
    throw new Error(`${errorJson.code} | ${errorJson.message}`);
  }
  const { data } = await response.json();
  return data;
}

// node_modules/thirdweb/dist/esm/bridge/Chains.js
async function chains(options) {
  const { client: client2 } = options;
  const clientFetch = getClientFetch(client2);
  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/chains`);
  const response = await clientFetch(url.toString());
  if (!response.ok) {
    const errorJson = await response.json();
    throw new Error(`${errorJson.code} | ${errorJson.message}`);
  }
  const { data } = await response.json();
  return data;
}

// node_modules/thirdweb/dist/esm/engine/index.js
var engine_exports = {};
__export(engine_exports, {
  getTransactionStatus: () => getTransactionStatus,
  serverWallet: () => serverWallet,
  waitForTransactionHash: () => waitForTransactionHash
});

// node_modules/@thirdweb-dev/engine/dist/esm/client/client.gen.js
var client = J(w({
  baseUrl: "http://localhost:3009"
}));

// node_modules/@thirdweb-dev/engine/dist/esm/client/sdk.gen.js
var sendTransaction2 = (options) => {
  return ((options == null ? void 0 : options.client) ?? client).post({
    security: [
      {
        name: "x-secret-key",
        type: "apiKey"
      }
    ],
    url: "/v1/write/transaction",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options == null ? void 0 : options.headers
    }
  });
};
var signMessage = (options) => {
  return ((options == null ? void 0 : options.client) ?? client).post({
    security: [
      {
        name: "x-secret-key",
        type: "apiKey"
      }
    ],
    url: "/v1/sign/message",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options == null ? void 0 : options.headers
    }
  });
};
var signTypedData = (options) => {
  return ((options == null ? void 0 : options.client) ?? client).post({
    security: [
      {
        name: "x-secret-key",
        type: "apiKey"
      }
    ],
    url: "/v1/sign/typed-data",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options == null ? void 0 : options.headers
    }
  });
};
var searchTransactions = (options) => {
  return ((options == null ? void 0 : options.client) ?? client).post({
    security: [
      {
        name: "x-secret-key",
        type: "apiKey"
      }
    ],
    url: "/v1/transactions/search",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options == null ? void 0 : options.headers
    }
  });
};

// node_modules/thirdweb/dist/esm/engine/get-status.js
async function getTransactionStatus(args) {
  var _a, _b, _c;
  const { client: client2, transactionId } = args;
  const searchResult = await searchTransactions({
    baseUrl: getThirdwebBaseUrl("engineCloud"),
    fetch: getClientFetch(client2),
    body: {
      filters: [
        {
          field: "id",
          values: [transactionId],
          operation: "OR"
        }
      ]
    }
  });
  if (searchResult.error) {
    throw new Error(`Error searching for transaction ${transactionId}: ${stringify(searchResult.error)}`);
  }
  const data = (_c = (_b = (_a = searchResult.data) == null ? void 0 : _a.result) == null ? void 0 : _b.transactions) == null ? void 0 : _c[0];
  if (!data) {
    throw new Error(`Transaction ${transactionId} not found`);
  }
  const executionResult = data.executionResult;
  return {
    ...executionResult,
    chain: getCachedChain(Number(data.chainId)),
    from: data.from ?? void 0,
    id: data.id
  };
}
async function waitForTransactionHash(args) {
  const startTime = Date.now();
  const TIMEOUT_IN_MS = args.timeoutInSeconds ? args.timeoutInSeconds * 1e3 : 5 * 60 * 1e3;
  while (Date.now() - startTime < TIMEOUT_IN_MS) {
    const executionResult = await getTransactionStatus(args);
    const status2 = executionResult.status;
    switch (status2) {
      case "FAILED": {
        throw new Error(`Transaction failed: ${executionResult.error || "Unknown error"}`);
      }
      case "CONFIRMED": {
        const onchainStatus = executionResult && "onchainStatus" in executionResult ? executionResult.onchainStatus : null;
        if (onchainStatus === "REVERTED") {
          const revertData = "revertData" in executionResult ? executionResult.revertData : void 0;
          throw new Error(`Transaction reverted: ${(revertData == null ? void 0 : revertData.errorName) || ""} ${(revertData == null ? void 0 : revertData.errorArgs) ? stringify(revertData.errorArgs) : ""}`);
        }
        return {
          transactionHash: executionResult.transactionHash,
          client: args.client,
          chain: executionResult.chain
        };
      }
      default: {
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
    }
  }
  throw new Error(`Transaction timed out after ${TIMEOUT_IN_MS / 1e3} seconds`);
}

// node_modules/thirdweb/dist/esm/engine/server-wallet.js
function serverWallet(options) {
  const { client: client2, vaultAccessToken, address, chain, executionOptions } = options;
  const headers = {
    "x-vault-access-token": vaultAccessToken
  };
  const getExecutionOptions = (chainId) => {
    return executionOptions ? {
      ...executionOptions,
      chainId: chainId.toString()
    } : {
      from: address,
      chainId: chainId.toString()
    };
  };
  const enqueueTx = async (transaction) => {
    var _a, _b, _c, _d;
    const body = {
      executionOptions: getExecutionOptions(transaction.chainId),
      params: [
        {
          to: transaction.to ?? void 0,
          data: transaction.data,
          value: (_a = transaction.value) == null ? void 0 : _a.toString()
        }
      ]
    };
    const result = await sendTransaction2({
      baseUrl: getThirdwebBaseUrl("engineCloud"),
      fetch: getClientFetch(client2),
      headers,
      body
    });
    if (result.error) {
      throw new Error(`Error sending transaction: ${result.error}`);
    }
    const data = (_b = result.data) == null ? void 0 : _b.result;
    if (!data) {
      throw new Error("No data returned from engine");
    }
    const transactionId = (_d = (_c = data.transactions) == null ? void 0 : _c[0]) == null ? void 0 : _d.id;
    if (!transactionId) {
      throw new Error("No transactionId returned from engine");
    }
    return transactionId;
  };
  return {
    address,
    enqueueTransaction: async (args) => {
      let serializedTransaction;
      if (args.simulate) {
        serializedTransaction = await toSerializableTransaction({
          transaction: args.transaction
        });
      } else {
        const [to, data, value] = await Promise.all([
          args.transaction.to ? resolvePromisedValue(args.transaction.to) : null,
          encode(args.transaction),
          args.transaction.value ? resolvePromisedValue(args.transaction.value) : null
        ]);
        serializedTransaction = {
          chainId: args.transaction.chain.id,
          data,
          to: to ?? void 0,
          value: value ?? void 0
        };
      }
      const transactionId = await enqueueTx(serializedTransaction);
      return { transactionId };
    },
    sendTransaction: async (transaction) => {
      const transactionId = await enqueueTx(transaction);
      return waitForTransactionHash({
        client: client2,
        transactionId
      });
    },
    signMessage: async (data) => {
      var _a, _b;
      const { message, chainId } = data;
      let engineMessage;
      let isBytes = false;
      if (typeof message === "string") {
        engineMessage = message;
      } else {
        engineMessage = toHex(message.raw);
        isBytes = true;
      }
      const signingChainId = chainId || (chain == null ? void 0 : chain.id);
      if (!signingChainId) {
        throw new Error("Chain ID is required for signing messages");
      }
      const signResult = await signMessage({
        baseUrl: getThirdwebBaseUrl("engineCloud"),
        fetch: getClientFetch(client2),
        headers,
        body: {
          executionOptions: getExecutionOptions(signingChainId),
          params: [
            {
              message: engineMessage,
              messageFormat: isBytes ? "hex" : "text"
            }
          ]
        }
      });
      if (signResult.error) {
        throw new Error(`Error signing message: ${stringify(signResult.error)}`);
      }
      const signatureResult = (_a = signResult.data) == null ? void 0 : _a.result.results[0];
      if (signatureResult == null ? void 0 : signatureResult.success) {
        return signatureResult.result.signature;
      }
      throw new Error(`Failed to sign message: ${((_b = signatureResult == null ? void 0 : signatureResult.error) == null ? void 0 : _b.message) || "Unknown error"}`);
    },
    signTypedData: async (typedData) => {
      var _a, _b;
      const signingChainId = chain == null ? void 0 : chain.id;
      if (!signingChainId) {
        throw new Error("Chain ID is required for signing messages");
      }
      const signResult = await signTypedData({
        baseUrl: getThirdwebBaseUrl("engineCloud"),
        fetch: getClientFetch(client2),
        headers,
        body: {
          executionOptions: getExecutionOptions(signingChainId),
          // biome-ignore lint/suspicious/noExplicitAny: TODO: fix ts / hey-api type clash
          params: [typedData]
        }
      });
      if (signResult.error) {
        throw new Error(`Error signing message: ${stringify(signResult.error)}`);
      }
      const signatureResult = (_a = signResult.data) == null ? void 0 : _a.result.results[0];
      if (signatureResult == null ? void 0 : signatureResult.success) {
        return signatureResult.result.signature;
      }
      throw new Error(`Failed to sign message: ${((_b = signatureResult == null ? void 0 : signatureResult.error) == null ? void 0 : _b.message) || "Unknown error"}`);
    }
  };
}

// node_modules/thirdweb/dist/esm/wallets/in-app/core/users/getUser.js
async function getUser({ client: client2, walletAddress, email, phone, id, externalWalletAddress, ecosystem }) {
  if (!client2.secretKey) {
    throw new Error("A secret key is required to query for users. If you're making this request from the server, please add a secret key to your client.");
  }
  const url = new URL(`${getThirdwebBaseUrl("inAppWallet")}/api/2023-11-30/embedded-wallet/user-details`);
  if (walletAddress) {
    url.searchParams.set("queryBy", "walletAddress");
    url.searchParams.set("walletAddress", walletAddress);
  } else if (email) {
    url.searchParams.set("queryBy", "email");
    url.searchParams.set("email", email);
  } else if (phone) {
    url.searchParams.set("queryBy", "phone");
    url.searchParams.set("phone", phone);
  } else if (id) {
    url.searchParams.set("queryBy", "id");
    url.searchParams.set("id", id);
  } else if (externalWalletAddress) {
    url.searchParams.set("queryBy", "externalWalletAddress");
    url.searchParams.set("externalWalletAddress", externalWalletAddress);
  } else {
    throw new Error("Please provide a walletAddress, email, phone, id, or externalWalletAddress to query for users.");
  }
  const clientFetch = getClientFetch(client2, ecosystem);
  const res = await clientFetch(url.toString());
  if (!res.ok) {
    const error = await res.text().catch(() => "Unknown error");
    throw new Error(`Failed to get profiles. ${res.status} ${res.statusText}: ${error}`);
  }
  const data = await res.json();
  return data.map((item) => ({
    userId: item.userId,
    walletAddress: item.walletAddress,
    smartAccountAddress: item.smartAccountAddress,
    email: item.email,
    phone: item.phone,
    createdAt: item.createdAt,
    profiles: item.linkedAccounts.map((profile) => {
      return {
        type: profile.type === "siwe" ? "wallet" : profile.type,
        details: profile.details
      };
    })
  }))[0] || null;
}

// node_modules/thirdweb/dist/esm/transaction/resolve-method.js
function resolveMethod(method) {
  return async (contract) => {
    var _a;
    if (typeof method === "string" && method.startsWith("function ")) {
      return parseAbiItem(method);
    }
    const resolvedAbi = ((_a = contract.abi) == null ? void 0 : _a.length) ? contract.abi : await resolveContractAbi(contract);
    const abiFunction = resolvedAbi.find((item) => {
      if (item.type !== "function") {
        return false;
      }
      return item.name === method;
    });
    if (!abiFunction) {
      throw new Error(`could not find function with name "${method}" in abi`);
    }
    return abiFunction;
  };
}

// node_modules/ox/_esm/core/internal/entropy.js
var extraEntropy = false;

// node_modules/ox/_esm/core/Secp256k1.js
function sign(options) {
  const { extraEntropy: extraEntropy2 = extraEntropy, hash, payload, privateKey } = options;
  const { r, s, recovery } = secp256k1.sign(from(payload), from(privateKey), {
    extraEntropy: typeof extraEntropy2 === "boolean" ? extraEntropy2 : from2(extraEntropy2).slice(2),
    lowS: true,
    ...hash ? { prehash: true } : {}
  });
  return {
    r,
    s,
    yParity: recovery
  };
}

// node_modules/thirdweb/dist/esm/transaction/actions/sign-transaction.js
function signTransaction({ transaction, privateKey }) {
  const serializedTransaction = serializeTransaction({ transaction });
  const signature = sign({
    payload: keccak256(serializedTransaction),
    privateKey
  });
  return serializeTransaction({
    transaction: { ...transaction, ...signature }
  });
}

// node_modules/thirdweb/dist/esm/auth/verify-typed-data.js
async function verifyTypedData({ address, signature, client: client2, chain, accountFactory, message, domain, primaryType, types }) {
  const messageHash = getSignPayload({
    message,
    domain,
    primaryType,
    types
  });
  return verifyHash({
    hash: messageHash,
    signature,
    address,
    chain,
    client: client2,
    accountFactory
  });
}

// node_modules/thirdweb/dist/esm/transaction/actions/eip7702/authorization.js
async function signAuthorization(options) {
  const { account, request } = options;
  if (typeof account.signAuthorization === "undefined") {
    throw new Error("This account type does not yet support signing EIP-7702 authorizations");
  }
  return account.signAuthorization(request);
}
export {
  ZERO_ADDRESS as ADDRESS_ZERO,
  bridge_exports as Bridge,
  engine_exports as Engine,
  insight_exports as Insight,
  NATIVE_TOKEN_ADDRESS,
  ZERO_ADDRESS,
  boolToBytes,
  boolToHex,
  bytesToBigInt,
  bytesToBool,
  bytesToNumber,
  bytesToString,
  concatHex,
  createThirdwebClient,
  defineChain,
  deploySmartAccount,
  encode,
  estimateGas,
  estimateGasCost,
  eth_blockNumber,
  eth_call,
  eth_estimateGas,
  eth_gasPrice,
  eth_getBalance,
  eth_getBlockByHash,
  eth_getBlockByNumber,
  eth_getCode,
  eth_getLogs,
  eth_getStorageAt,
  eth_getTransactionByHash,
  eth_getTransactionCount,
  eth_getTransactionReceipt,
  eth_maxPriorityFeePerGas,
  eth_sendRawTransaction,
  fromBytes,
  fromGwei,
  fromHex,
  getAddress,
  getBuyWithCryptoHistory,
  getBuyWithCryptoQuote,
  getBuyWithCryptoStatus,
  getBuyWithCryptoTransfer,
  getContract,
  getContractEvents,
  getGasPrice,
  getRpcClient,
  getUser,
  hexToBigInt,
  hexToBool,
  hexToBytes,
  hexToNumber,
  hexToString,
  hexToUint8Array,
  isAddress,
  isBaseTransactionOptions,
  isHex,
  keccak2562 as keccak256,
  numberToBytes,
  numberToHex,
  padHex,
  parseEventLogs,
  prepareContractCall,
  prepareEvent,
  prepareTransaction,
  readContract,
  resolveMethod,
  sendAndConfirmTransaction,
  sendBatchTransaction,
  sendTransaction,
  serializeTransaction,
  sha2562 as sha256,
  signAuthorization,
  signTransaction,
  simulateTransaction,
  stringToBytes,
  stringToHex,
  toBytes,
  toEther,
  toHex,
  toSerializableTransaction,
  toTokens,
  toUnits,
  toWei,
  uint8ArrayToHex,
  verifyTypedData,
  waitForReceipt,
  watchBlockNumber,
  watchContractEvents
};
//# sourceMappingURL=thirdweb.js.map
