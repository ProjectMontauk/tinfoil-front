{
  "version": 3,
  "sources": ["../../thirdweb/src/extensions/erc7702/__generated__/MinimalAccount/write/execute.ts", "../../thirdweb/src/wallets/in-app/core/eip7702/minimal-account.ts", "../../thirdweb/src/wallets/in-app/core/wallet/index.ts"],
  "sourcesContent": ["import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport type {\n  BaseTransactionOptions,\n  WithOverrides,\n} from \"../../../../../transaction/types.js\";\nimport { prepareContractCall } from \"../../../../../transaction/prepare-contract-call.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { once } from \"../../../../../utils/promise/once.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"execute\" function.\n */\nexport type ExecuteParams = WithOverrides<{\n  calls: AbiParameterToPrimitiveType<{\n    type: \"tuple[]\";\n    name: \"calls\";\n    components: [\n      { type: \"address\"; name: \"target\" },\n      { type: \"uint256\"; name: \"value\" },\n      { type: \"bytes\"; name: \"data\" },\n    ];\n  }>;\n}>;\n\nexport const FN_SELECTOR = \"0x3f707e6b\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"tuple[]\",\n    name: \"calls\",\n    components: [\n      {\n        type: \"address\",\n        name: \"target\",\n      },\n      {\n        type: \"uint256\",\n        name: \"value\",\n      },\n      {\n        type: \"bytes\",\n        name: \"data\",\n      },\n    ],\n  },\n] as const;\nconst FN_OUTPUTS = [] as const;\n\n/**\n * Checks if the `execute` method is supported by the given contract.\n * @param availableSelectors An array of 4byte function selectors of the contract. You can get this in various ways, such as using \"whatsabi\" or if you have the ABI of the contract available you can use it to generate the selectors.\n * @returns A boolean indicating if the `execute` method is supported.\n * @extension ERC7702\n * @example\n * ```ts\n * import { isExecuteSupported } from \"thirdweb/extensions/erc7702\";\n *\n * const supported = isExecuteSupported([\"0x...\"]);\n * ```\n */\nexport function isExecuteSupported(availableSelectors: string[]) {\n  return detectMethod({\n    availableSelectors,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"execute\" function.\n * @param options - The options for the execute function.\n * @returns The encoded ABI parameters.\n * @extension ERC7702\n * @example\n * ```ts\n * import { encodeExecuteParams } from \"thirdweb/extensions/erc7702\";\n * const result = encodeExecuteParams({\n *  calls: ...,\n * });\n * ```\n */\nexport function encodeExecuteParams(options: ExecuteParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.calls]);\n}\n\n/**\n * Encodes the \"execute\" function into a Hex string with its parameters.\n * @param options - The options for the execute function.\n * @returns The encoded hexadecimal string.\n * @extension ERC7702\n * @example\n * ```ts\n * import { encodeExecute } from \"thirdweb/extensions/erc7702\";\n * const result = encodeExecute({\n *  calls: ...,\n * });\n * ```\n */\nexport function encodeExecute(options: ExecuteParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeExecuteParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Prepares a transaction to call the \"execute\" function on the contract.\n * @param options - The options for the \"execute\" function.\n * @returns A prepared transaction object.\n * @extension ERC7702\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n * import { execute } from \"thirdweb/extensions/erc7702\";\n *\n * const transaction = execute({\n *  contract,\n *  calls: ...,\n *  overrides: {\n *    ...\n *  }\n * });\n *\n * // Send the transaction\n * await sendTransaction({ transaction, account });\n * ```\n */\nexport function execute(\n  options: BaseTransactionOptions<\n    | ExecuteParams\n    | {\n        asyncParams: () => Promise<ExecuteParams>;\n      }\n  >,\n) {\n  const asyncOptions = once(async () => {\n    return \"asyncParams\" in options ? await options.asyncParams() : options;\n  });\n\n  return prepareContractCall({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: async () => {\n      const resolvedOptions = await asyncOptions();\n      return [resolvedOptions.calls] as const;\n    },\n    value: async () => (await asyncOptions()).overrides?.value,\n    accessList: async () => (await asyncOptions()).overrides?.accessList,\n    gas: async () => (await asyncOptions()).overrides?.gas,\n    gasPrice: async () => (await asyncOptions()).overrides?.gasPrice,\n    maxFeePerGas: async () => (await asyncOptions()).overrides?.maxFeePerGas,\n    maxPriorityFeePerGas: async () =>\n      (await asyncOptions()).overrides?.maxPriorityFeePerGas,\n    nonce: async () => (await asyncOptions()).overrides?.nonce,\n    extraGas: async () => (await asyncOptions()).overrides?.extraGas,\n    erc20Value: async () => (await asyncOptions()).overrides?.erc20Value,\n    authorizationList: async () =>\n      (await asyncOptions()).overrides?.authorizationList,\n  });\n}\n", "import type { Definition, TypedData } from \"ox/TypedData\";\nimport type { Hex, SignableMessage } from \"viem\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getBytecode } from \"../../../../contract/actions/get-bytecode.js\";\nimport {\n  type ThirdwebContract,\n  getContract,\n} from \"../../../../contract/contract.js\";\nimport { execute } from \"../../../../extensions/erc7702/__generated__/MinimalAccount/write/execute.js\";\nimport type { SignedAuthorization } from \"../../../../transaction/actions/eip7702/authorization.js\";\nimport { toSerializableTransaction } from \"../../../../transaction/actions/to-serializable-transaction.js\";\nimport type { SendTransactionResult } from \"../../../../transaction/types.js\";\nimport { getAddress } from \"../../../../utils/address.js\";\nimport { randomBytesHex } from \"../../../../utils/random.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n} from \"../../../interfaces/wallet.js\";\nimport {\n  executeWithSignature,\n  getQueuedTransactionHash,\n} from \"../../../smart/lib/bundler.js\";\nimport type { BundlerOptions } from \"../../../smart/types.js\";\n\nconst MINIMAL_ACCOUNT_IMPLEMENTATION_ADDRESS =\n  \"0xbaC7e770af15d130Cd72838ff386f14FBF3e9a3D\";\n\nexport const create7702MinimalAccount = (args: {\n  client: ThirdwebClient;\n  adminAccount: Account;\n  sponsorGas?: boolean;\n}): Account => {\n  const { client, adminAccount, sponsorGas } = args;\n\n  const _sendTxWithAuthorization = async (txs: SendTransactionOption[]) => {\n    const firstTx = txs[0];\n    if (!firstTx) {\n      throw new Error(\"No transactions provided\");\n    }\n    const chain = getCachedChain(firstTx.chainId);\n    const eoaContract = getContract({\n      address: adminAccount.address,\n      client,\n      chain,\n    });\n    // check if account has been delegated already\n    let authorization: SignedAuthorization | undefined = undefined;\n    const isMinimalAccount = await is7702MinimalAccount(eoaContract);\n    if (!isMinimalAccount) {\n      // if not, sign authorization\n      const nonce = firstTx.nonce\n        ? BigInt(firstTx.nonce) + (sponsorGas ? 0n : 1n)\n        : 0n; // TODO (7702): get remote nonce if not provided, should be in the tx though\n      const auth = await adminAccount.signAuthorization?.({\n        address: MINIMAL_ACCOUNT_IMPLEMENTATION_ADDRESS,\n        chainId: firstTx.chainId,\n        nonce,\n      });\n      if (!auth) {\n        throw new Error(\"Failed to sign authorization\");\n      }\n      authorization = auth;\n    }\n    if (sponsorGas) {\n      // send transaction from executor, needs signature\n      const wrappedCalls = {\n        calls: txs.map((tx) => ({\n          target: getAddress(tx.to ?? \"\"), // will throw if undefined address\n          value: tx.value ?? 0n,\n          data: tx.data ?? \"0x\",\n        })),\n        uid: randomBytesHex(),\n      };\n      const signature = await adminAccount.signTypedData({\n        domain: {\n          name: \"MinimalAccount\",\n          version: \"1\",\n          chainId: firstTx.chainId,\n          verifyingContract: eoaContract.address,\n        },\n        types: {\n          WrappedCalls: [\n            { name: \"calls\", type: \"Call[]\" },\n            { name: \"uid\", type: \"bytes32\" },\n          ],\n          Call: [\n            { name: \"target\", type: \"address\" },\n            { name: \"value\", type: \"uint256\" },\n            { name: \"data\", type: \"bytes\" },\n          ],\n        },\n        message: wrappedCalls,\n        primaryType: \"WrappedCalls\",\n      });\n\n      const result = await executeWithSignature({\n        eoaAddress: getAddress(adminAccount.address),\n        wrappedCalls,\n        signature,\n        authorization,\n        options: {\n          client,\n          chain: getCachedChain(firstTx.chainId),\n        },\n      });\n\n      const transactionHash = await waitForTransactionHash({\n        options: {\n          client,\n          chain: getCachedChain(firstTx.chainId),\n        },\n        transactionId: result.transactionId,\n      });\n      return {\n        transactionHash,\n      };\n    }\n    // send transaction from EOA\n    // wrap txs in a single execute call to the MinimalAccount\n    const executeTx = execute({\n      contract: eoaContract,\n      calls: txs.map((tx) => ({\n        target: tx.to ?? \"\",\n        value: tx.value ?? 0n,\n        data: tx.data ?? \"0x\",\n      })),\n      overrides: {\n        value: txs.reduce((acc, tx) => acc + (tx.value ?? 0n), 0n),\n        authorizationList: authorization ? [authorization] : undefined,\n      },\n    });\n    // re-estimate gas for the entire batch + authorization\n    const serializedTx = await toSerializableTransaction({\n      transaction: executeTx,\n      from: adminAccount.address,\n    });\n    return adminAccount.sendTransaction(serializedTx);\n  };\n\n  const minimalAccount: Account = {\n    address: adminAccount.address,\n    sendTransaction: async (\n      tx: SendTransactionOption,\n    ): Promise<SendTransactionResult> => {\n      return _sendTxWithAuthorization([tx]);\n    },\n    sendBatchTransaction: async (\n      txs: SendTransactionOption[],\n    ): Promise<SendTransactionResult> => {\n      return _sendTxWithAuthorization(txs);\n    },\n    signMessage: ({\n      message,\n      originalMessage,\n      chainId,\n    }: {\n      message: SignableMessage;\n      originalMessage?: string;\n      chainId?: number;\n    }): Promise<Hex> =>\n      adminAccount.signMessage({ message, originalMessage, chainId }),\n    signTypedData: <\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(\n      _typedData: Definition<typedData, primaryType>,\n    ): Promise<Hex> => adminAccount.signTypedData(_typedData),\n  };\n  return minimalAccount;\n};\n\nasync function is7702MinimalAccount(\n  eoaContract: ThirdwebContract,\n): Promise<boolean> {\n  const code = await getBytecode(eoaContract);\n  const isDelegated = code.length > 0 && code.startsWith(\"0xef0100\");\n  const target = `0x${code.slice(8, 48)}`;\n  return (\n    isDelegated &&\n    target.toLowerCase() ===\n      MINIMAL_ACCOUNT_IMPLEMENTATION_ADDRESS.toLowerCase()\n  );\n}\n\nasync function waitForTransactionHash(args: {\n  options: BundlerOptions;\n  transactionId: string;\n  timeoutMs?: number;\n  intervalMs?: number;\n}): Promise<Hex> {\n  const timeout = args.timeoutMs || 120000; // 2mins\n  const interval = args.intervalMs || 1000; // 1s\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const result = await getQueuedTransactionHash({\n      options: args.options,\n      transactionId: args.transactionId,\n    });\n    if (result.transactionHash) {\n      return result.transactionHash;\n    }\n    await new Promise((resolve) => setTimeout(resolve, interval));\n  }\n  throw new Error(\n    `Timeout waiting for transaction to be mined on chain ${args.options.chain.id} with transactionId: ${args.transactionId}`,\n  );\n}\n", "import { ethereum } from \"../../../../chains/chain-definitions/ethereum.js\";\nimport type { Chain } from \"../../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport {\n  type SocialAuthOption,\n  socialAuthOptions,\n} from \"../../../../wallets/types.js\";\nimport type {\n  EcosystemWalletConnectionOptions,\n  EcosystemWalletCreationOptions,\n} from \"../../../ecosystem/types.js\";\nimport type { Account, Wallet } from \"../../../interfaces/wallet.js\";\nimport type { SmartWalletOptions } from \"../../../smart/types.js\";\nimport type {\n  EcosystemWalletId,\n  WalletAutoConnectionOption,\n  WalletId,\n} from \"../../../wallet-types.js\";\nimport type { CreateWalletArgs } from \"../../../wallet-types.js\";\nimport { create7702MinimalAccount } from \"../eip7702/minimal-account.js\";\nimport type { InAppConnector } from \"../interfaces/connector.js\";\nimport type {\n  ExecutionModeOptions,\n  InAppWalletConnectionOptions,\n  InAppWalletCreationOptions,\n} from \"./types.js\";\n\n/**\n * Checks if the provided wallet is an in-app wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is an in-app wallet, false otherwise.\n */\nexport function isInAppWallet(\n  wallet: Wallet<WalletId>,\n): wallet is Wallet<\"inApp\" | \"embedded\"> {\n  return wallet.id === \"inApp\" || wallet.id === \"embedded\";\n}\n\n/**\n * @internal\n */\nexport async function connectInAppWallet(\n  options: InAppWalletConnectionOptions | EcosystemWalletConnectionOptions,\n  createOptions: InAppWalletCreationOptions | EcosystemWalletCreationOptions,\n  connector: InAppConnector,\n): Promise<{ account: Account; chain: Chain; adminAccount?: Account }> {\n  if (\n    // if auth mode is not specified, the default is popup\n    createOptions?.auth?.mode !== \"popup\" &&\n    createOptions?.auth?.mode !== undefined &&\n    connector.authenticateWithRedirect\n  ) {\n    const strategy = options.strategy;\n    if (socialAuthOptions.includes(strategy as SocialAuthOption)) {\n      await connector.authenticateWithRedirect(\n        strategy as SocialAuthOption,\n        createOptions?.auth?.mode,\n        createOptions?.auth?.redirectUrl,\n      );\n    }\n  }\n  // If we don't have authenticateWithRedirect then it's likely react native, so the default is to redirect and we can carry on\n  // IF WE EVER ADD MORE CONNECTOR TYPES, this could cause redirect to be ignored despite being specified\n  // TODO: In V6, make everything redirect auth\n\n  const authResult = await connector.connect(options);\n  const authAccount = authResult.user.account;\n\n  return createInAppAccount({\n    client: options.client,\n    authAccount,\n    createOptions,\n    desiredChain: options.chain,\n  });\n}\n\n/**\n * @internal\n */\nexport async function autoConnectInAppWallet(\n  options:\n    | WalletAutoConnectionOption<\"inApp\">\n    | WalletAutoConnectionOption<EcosystemWalletId>,\n  createOptions:\n    | CreateWalletArgs<\"inApp\">[1]\n    | CreateWalletArgs<EcosystemWalletId>[1],\n  connector: InAppConnector,\n): Promise<{ account: Account; chain: Chain; adminAccount?: Account }> {\n  if (options.authResult && connector.loginWithAuthToken) {\n    await connector.loginWithAuthToken(options.authResult);\n  }\n\n  const user = await getAuthenticatedUser(connector);\n  if (!user) {\n    throw new Error(\"Failed to authenticate user.\");\n  }\n\n  const authAccount = user.account;\n\n  return createInAppAccount({\n    client: options.client,\n    authAccount,\n    createOptions,\n    desiredChain: options.chain,\n  });\n}\n\nasync function convertToSmartAccount(options: {\n  client: ThirdwebClient;\n  authAccount: Account;\n  smartAccountOptions: CreateWalletArgs<\"smart\">[1];\n  chain?: Chain;\n}) {\n  const { connectSmartAccount } = await import(\"../../../smart/index.js\");\n\n  return connectSmartAccount(\n    {\n      client: options.client,\n      personalAccount: options.authAccount,\n      chain: options.chain,\n    },\n    options.smartAccountOptions,\n  );\n}\n\nasync function getAuthenticatedUser(connector: InAppConnector) {\n  const user = await connector.getUser();\n  switch (user.status) {\n    case \"Logged In, Wallet Initialized\": {\n      return user;\n    }\n  }\n  return undefined;\n}\n\nasync function createInAppAccount(options: {\n  client: ThirdwebClient;\n  authAccount: Account;\n  createOptions: InAppWalletCreationOptions | EcosystemWalletCreationOptions;\n  desiredChain?: Chain;\n}) {\n  const { createOptions, authAccount, desiredChain, client } = options;\n  let smartAccountOptions: SmartWalletOptions | undefined;\n  let eip7702: Extract<ExecutionModeOptions, { mode: \"EIP7702\" }> | undefined;\n  const executionMode =\n    createOptions && \"executionMode\" in createOptions\n      ? createOptions.executionMode\n      : undefined;\n\n  if (executionMode) {\n    if (executionMode.mode === \"EIP4337\") {\n      smartAccountOptions = executionMode.smartAccount;\n    } else if (executionMode.mode === \"EIP7702\") {\n      eip7702 = executionMode;\n    }\n  }\n\n  // backwards compatibility\n  if (\n    createOptions &&\n    \"smartAccount\" in createOptions &&\n    createOptions?.smartAccount\n  ) {\n    smartAccountOptions = createOptions.smartAccount;\n  }\n\n  if (smartAccountOptions) {\n    const [account, chain] = await convertToSmartAccount({\n      client,\n      authAccount,\n      smartAccountOptions,\n      chain: desiredChain,\n    });\n    return { account, chain, adminAccount: authAccount };\n  }\n\n  if (eip7702) {\n    const chain = desiredChain;\n    if (!chain) {\n      throw new Error(\n        \"Chain is required for EIP-7702 execution, pass a chain when connecting the inAppWallet.\",\n      );\n    }\n    const account = create7702MinimalAccount({\n      client,\n      adminAccount: authAccount,\n      sponsorGas: eip7702.sponsorGas,\n    });\n    return {\n      account,\n      chain,\n      adminAccount: authAccount,\n    };\n  }\n\n  return { account: authAccount, chain: desiredChain || ethereum } as const;\n}\n"],
  "mappings": "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",
  "names": []
}
